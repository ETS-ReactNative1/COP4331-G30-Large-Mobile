{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAOgBA;QAIAC;QAuBAC;QAOAC;QAOAC;QAoBAC;QAkBAC;QAuBAC;QAIAC;QAaAC;QAyCAC;QASAC;QAmBAC;;;;;;AAnMhB;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEO,SAASZ,WAAT,CAAqBa,IAArB,EAA2B;AAChC,SAAQA,QAAQA,KAAKC,KAAbD,IAAuB,EAA/B;AACD;;AAEM,SAASZ,cAAT,CAAwBY,IAAxB,EAA8B;AACnC,MAAI,CAACA,IAAL,EAAW,OAAO,EAAP;AAEX,MAAME,UAAU,8BAAhB;AACA,MAAMC,uBAAuBD,QAAQE,UAARF,IAAsB,OAAOA,QAAQE,UAAf,KAA8B,UAAjF;AAEA,MAAMC,gBAAgBC,MAAMC,OAAND,CAAcN,KAAKQ,QAAnBF,IAA+B,iCAAKN,KAAKQ,QAAV,EAAoB,CAApB,CAA/BF,GAAwD,CAACN,KAAKQ,QAAN,CAA9E,CANmC,CAQnC;;AACA,MAAI,CAACL,oBAAL,EAA2B;AACzB,WAAOE,aAAP;AACD;;AAED,SAAO,iCAAKA,cAAcI,GAAdJ,CAAkB,UAACK,YAAD,EAAkB;AAC9C;AACA,QAAIR,QAAQE,UAARF,CAAmBQ,YAAnBR,CAAJ,EAAsC;AACpC,aAAOd,eAAesB,YAAftB,CAAP;AACD;;AAED,WAAOsB,YAAP;AANU,IAAL,EAOH,CAPG,CAAP;AAQD;;AAEM,SAASrB,YAAT,CAAsBW,IAAtB,EAA4BW,SAA5B,EAAuC;AAC5C,MAAIC,UAAUzB,YAAYa,IAAZb,EAAkBwB,SAAlBxB,IAA+B,EAA7C;AACAyB,YAAUC,OAAOD,OAAPC,EAAgBC,OAAhBD,CAAwB,KAAxBA,EAA+B,GAA/BA,CAAVD;AACA,MAAI,0BAAQD,SAAR,CAAJ,EAAwB,OAAOA,UAAUI,IAAVJ,CAAeC,OAAfD,CAAP;AACxB,SAAO,cAAIC,OAAJ,SAAeI,OAAf,cAA2BL,SAA3B,WAA2C,CAAC,CAAnD;AACD;;AAEM,SAASrB,WAAT,CAAqB2B,IAArB,EAA2BC,EAA3B,EAA+B;AACpC,MAAID,IAAJ,EAAU;AACRC,OAAGD,IAAHC;AACD;;AACD9B,iBAAe6B,IAAf7B,EAAqB+B,OAArB/B,CAA6B,UAACY,IAAD;AAAA,WAAUV,YAAYU,IAAZV,EAAkB4B,EAAlB5B,CAAV;AAA7B;AACD;;AAEM,SAASC,UAAT,CAAoB0B,IAApB,EAA0BC,EAA1B,EAA8B;AACnC,MAAME,UAAU,EAAhB;AACA9B,cAAY2B,IAAZ3B,EAAkB,UAACU,IAAD,EAAU;AAC1B,QAAIkB,GAAGlB,IAAHkB,CAAJ,EAAc;AACZE,cAAQC,IAARD,CAAapB,IAAboB;AACD;AAHH;AAKA,SAAOA,OAAP;AACD;AAED;;;;;;;;;;;;AAUO,SAAS5B,cAAT,CAAwB8B,IAAxB,EAA8BC,UAA9B,EAA0C;AAC/C,MAAMH,UAAU7B,WACd+B,IADc/B,EAEd,UAACS,IAAD,EAAU;AACR,QAAI,CAACA,KAAKQ,QAAV,EAAoB;AAClB,aAAO,KAAP;AACD;;AAED,WAAOpB,eAAeY,IAAfZ,EAAqB4B,OAArB5B,CAA6BmC,UAA7BnC,MAA6C,CAAC,CAArD;AAPY,IAAhB;AAUA,SAAOgC,QAAQ,CAARA,KAAc,IAArB;AACD;;AAED,SAASI,UAAT,CAAoBC,IAApB,EAA0BP,EAA1B,EAA8B;AAC5B,SAAOO,KAAKC,MAALD,CAAY,UAACR,IAAD;AAAA,WAAU1B,WAAW0B,IAAX1B,EAAiB2B,EAAjB3B,EAAqBoC,MAArBpC,KAAgC,CAA1C;AAAZ,IAAP;AACD;;AAEM,SAASE,UAAT,CAAoBO,IAApB,EAA0BsB,IAA1B,EAAgC;AACrC,MAAMM,QAAQ,CAACN,IAAD,CAAd;AACA,MAAMG,OAAO,EAAb;;AAEA,MAAMI,UAAU,SAAVA,OAAU,CAACC,QAAD;AAAA,WAAc9B,SAAS8B,QAAvB;AAAhB;;AAEA,SAAOF,MAAMD,MAAb,EAAqB;AACnB,QAAMI,UAAUH,MAAMI,GAANJ,EAAhB;AACA,QAAMK,WAAW7C,eAAe2C,OAAf3C,CAAjB;AACA,QAAI2C,YAAY/B,IAAhB,EAAsB,OAAOwB,WAAWC,IAAXD,EAAiBK,OAAjBL,CAAP;AAEtBC,SAAKJ,IAALI,CAAUM,OAAVN;;AAEA,QAAIQ,SAASN,MAATM,KAAoB,CAAxB,EAA2B;AACzB;AACAR,WAAKO,GAALP;AACD;;AACDG,UAAMP,IAANO,iCAAcK,QAAd;AACD;;AAED,SAAO,IAAP;AACD;;AAEM,SAASvC,aAAT,CAAuBM,IAAvB,EAA6BsB,IAA7B,EAAmC;AACxC,SAAO,CAAC7B,WAAWO,IAAXP,EAAiB6B,IAAjB7B,KAA0B,EAA3B,EAA+ByC,OAA/B,EAAP;AACD;;AAEM,SAASvC,SAAT,CAAmBK,IAAnB,EAAyBmC,EAAzB,EAA6B;AAClC,SAAOhD,YAAYa,IAAZb,EAAkBgD,EAAlBhD,KAAyBgD,EAAhC;AACD;;AAED,IAAMC,kBAAkB,EAAxB;;AACA,SAASC,gBAAT,CAA0BC,CAA1B,EAA6B;AAC3B,SAAO,OAAOA,CAAP,KAAa,WAAb,GAA2BA,CAA3B,GAA+BF,eAAtC;AACD;;AACD,SAASG,sBAAT,CAAgCC,GAAhC,EAAqC;AACnC,SAAO,yBAAQA,GAAR,EACJC,MADI,CACG,UAACC,GAAD;AAAA;AAAA,QAAOC,CAAP;AAAA,QAAUL,CAAV;;AAAA,wCAAuBI,GAAvB,sBAA6BC,CAA7B,EAAiCN,iBAAiBC,CAAjBD,CAAjC;AADH,KAC4D,EAD5D,CAAP;AAED;;AAEM,SAASzC,sBAAT,CAAgCI,IAAhC,EAAsCC,KAAtC,EAA6C;AAClD,SAAO,2BAASd,YAAYa,IAAZb,CAAT,EAA4BoD,uBAAuBtC,KAAvBsC,CAA5B,CAAP;AACD;;AAED,SAASK,mBAAT,CAA6BC,QAA7B,EAAuC;AACrC,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChC,WAAOhC,OAAOgC,YAAY,EAAnBhC,CAAP;AACD;;AACD,MAAI,CAACgC,QAAL,EAAe;AACb,WAAO,EAAP;AACD;;AACD,SAAOA,SAASC,WAATD,IAAwB,EAA/B;AACD;;AAED,SAASE,kBAAT,CAA4B/C,IAA5B,SAKG;AAAA,MAJDgD,SAIC,SAJDA,SAIC;AAAA,MAHDC,eAGC,SAHDA,eAGC;AAAA,MAFDC,OAEC,SAFDA,OAEC;AAAA,oCADDC,qBACC;AAAA,MADDA,qBACC,yCADuB,KACvB;;AACD,MAAInD,QAAQ,IAAZ,EAAkB;AAChB,WAAO,EAAP;AACD;;AAED,MAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,QAAhD,EAA0D;AACxD,WAAOa,OAAOb,IAAPa,CAAP;AACD;;AAED,MAAImC,aAAahD,KAAKoD,IAAlBJ,IAA0B,OAAOhD,KAAKoD,IAAZ,KAAqB,UAAnD,EAA+D;AAC7D,WAAOJ,UAAUhD,IAAVgD,CAAP;AACD;;AAED,MAAIC,mBAAmBjD,KAAKqD,QAALrD,KAAkB,MAAzC,EAAiD;AAC/C,WAAOiD,gBAAgBjD,IAAhBiD,CAAP;AACD;;AACD,MAAIjD,KAAKQ,QAALR,IAAiB,IAAjBA,IAAyBmD,qBAA7B,EAAoD;AAClD,WAAO,IAAP;AACD;;AACD,SAAO/D,eAAeY,IAAfZ,EAAqBqB,GAArBrB,CAAyB8D,OAAzB9D,EAAkCkE,IAAlClE,CAAuC,EAAvCA,CAAP;AACD;;AAEM,SAASS,eAAT,CAAyBG,IAAzB,EAA+B;AACpC,SAAO+C,mBAAmB/C,IAAnB+C,EAAyB;AAC9BG,aAASrD,eADqB;AAE9BmD,aAF8B;AAAA,gCAEV;AAAA,YAARI,IAAQ,SAARA,IAAQ;AAClB,4BAAWA,KAAKG,WAALH,IAAoB,oCAAaA,IAAb,CAA/B;AACD;;AAJ6B;AAAA;AAAA,GAAzBL,CAAP;AAMD;;AAEM,SAASjD,oBAAT,CAA8BE,IAA9B,EAAoCE,OAApC,EAA6C;AAClD,SAAO6C,mBAAmB/C,IAAnB+C,EAAyB;AAC9BG,WAD8B;AAAA,uBACtBM,IADsB,EAChB;AACZ,eAAO1D,qBAAqB0D,IAArB1D,EAA2BI,OAA3BJ,CAAP;AACD;;AAH6B;AAAA;AAI9BmD,mBAJ8B;AAAA,+BAIdO,IAJc,EAIR;AACpB,YAAMC,QAAQ,GAAGC,MAAH,CAAUxD,QAAQyD,cAARzD,CAAuBsD,IAAvBtD,EAA6B,IAA7BA,CAAV,CAAd;AACA,eAAOuD,MAAMhD,GAANgD,CAAUb,mBAAVa,EAA+BH,IAA/BG,CAAoC,EAApCA,CAAP;AACD;;AAP6B;AAAA;AAAA,GAAzBV,CAAP;AASD;;AAED,SAASa,mBAAT,CAA6Bf,QAA7B,EAAuC;AACrC,MAAIA,YAAY,IAAhB,EAAsB;AACpB,WAAO,IAAP;AACD;;AACD,SAAOA,SAASgB,SAAThB,CAAmB/B,OAAnB+B,CAA2B,yCAA3BA,EAAsE,EAAtEA,CAAP;AACD;;AAEM,SAAS9C,oBAAT,CAA8BC,IAA9B,EAAoCE,OAApC,EAA6C;AAClD,SAAO6C,mBAAmB/C,IAAnB+C,EAAyB;AAC9BG,WAD8B;AAAA,uBACtBM,IADsB,EAChB;AACZ,eAAOzD,qBAAqByD,IAArBzD,EAA2BG,OAA3BH,CAAP;AACD;;AAH6B;AAAA;AAI9BkD,mBAJ8B;AAAA,+BAIdO,IAJc,EAIR;AACpB,YAAMC,QAAQ,GAAGC,MAAH,CAAUxD,QAAQyD,cAARzD,CAAuBsD,IAAvBtD,EAA6B,IAA7BA,CAAV,CAAd;AACA,eAAOuD,MAAMhD,GAANgD,CAAUG,mBAAVH,EAA+BH,IAA/BG,CAAoC,EAApCA,CAAP;AACD;;AAP6B;AAAA;AAQ9BN,2BAAuB;AARO,GAAzBJ,CAAP;AAUD,C","names":["propsOfNode","childrenOfNode","hasClassName","treeForEach","treeFilter","findParentNode","pathToNode","parentsOfNode","nodeHasId","nodeMatchesObjectProps","getTextFromNode","getTextFromHostNodes","getHTMLFromHostNodes","node","props","adapter","adapterHasIsFragment","isFragment","renderedArray","Array","isArray","rendered","map","currentChild","className","classes","String","replace","test","indexOf","tree","fn","forEach","results","push","root","targetNode","pathFilter","path","filter","length","queue","hasNode","testNode","current","pop","children","reverse","id","CAN_NEVER_MATCH","replaceUndefined","v","replaceUndefinedValues","obj","reduce","acc","k","getTextFromHostNode","hostNode","textContent","getTextFromRSTNode","getCustom","handleHostNodes","recurse","nullRenderReturnsNull","type","nodeType","join","displayName","item","nodes","concat","nodeToHostNode","getHTMLFromHostNode","outerHTML"],"sources":["../src/RSTTraversal.js"],"sourcesContent":["import flat from 'array.prototype.flat';\nimport entries from 'object.entries';\nimport isSubset from 'is-subset';\nimport functionName from 'function.prototype.name';\nimport isRegex from 'is-regex';\nimport getAdapter from './getAdapter';\n\nexport function propsOfNode(node) {\n  return (node && node.props) || {};\n}\n\nexport function childrenOfNode(node) {\n  if (!node) return [];\n\n  const adapter = getAdapter();\n  const adapterHasIsFragment = adapter.isFragment && typeof adapter.isFragment === 'function';\n\n  const renderedArray = Array.isArray(node.rendered) ? flat(node.rendered, 1) : [node.rendered];\n\n  // React adapters before 16 will not have isFragment\n  if (!adapterHasIsFragment) {\n    return renderedArray;\n  }\n\n  return flat(renderedArray.map((currentChild) => {\n    // If the node is a Fragment, we want to return its children, not the fragment itself\n    if (adapter.isFragment(currentChild)) {\n      return childrenOfNode(currentChild);\n    }\n\n    return currentChild;\n  }), 1);\n}\n\nexport function hasClassName(node, className) {\n  let classes = propsOfNode(node).className || '';\n  classes = String(classes).replace(/\\s/g, ' ');\n  if (isRegex(className)) return className.test(classes);\n  return ` ${classes} `.indexOf(` ${className} `) > -1;\n}\n\nexport function treeForEach(tree, fn) {\n  if (tree) {\n    fn(tree);\n  }\n  childrenOfNode(tree).forEach((node) => treeForEach(node, fn));\n}\n\nexport function treeFilter(tree, fn) {\n  const results = [];\n  treeForEach(tree, (node) => {\n    if (fn(node)) {\n      results.push(node);\n    }\n  });\n  return results;\n}\n\n/**\n * To support sibling selectors we need to be able to find\n * the siblings of a node. The easiest way to do that is find\n * the parent of the node and access its children.\n *\n * This would be unneeded if the RST spec included sibling pointers\n * such as node.nextSibling and node.prevSibling\n * @param {*} root\n * @param {*} targetNode\n */\nexport function findParentNode(root, targetNode) {\n  const results = treeFilter(\n    root,\n    (node) => {\n      if (!node.rendered) {\n        return false;\n      }\n\n      return childrenOfNode(node).indexOf(targetNode) !== -1;\n    },\n  );\n  return results[0] || null;\n}\n\nfunction pathFilter(path, fn) {\n  return path.filter((tree) => treeFilter(tree, fn).length !== 0);\n}\n\nexport function pathToNode(node, root) {\n  const queue = [root];\n  const path = [];\n\n  const hasNode = (testNode) => node === testNode;\n\n  while (queue.length) {\n    const current = queue.pop();\n    const children = childrenOfNode(current);\n    if (current === node) return pathFilter(path, hasNode);\n\n    path.push(current);\n\n    if (children.length === 0) {\n      // leaf node. if it isn't the node we are looking for, we pop.\n      path.pop();\n    }\n    queue.push(...children);\n  }\n\n  return null;\n}\n\nexport function parentsOfNode(node, root) {\n  return (pathToNode(node, root) || []).reverse();\n}\n\nexport function nodeHasId(node, id) {\n  return propsOfNode(node).id === id;\n}\n\nconst CAN_NEVER_MATCH = {};\nfunction replaceUndefined(v) {\n  return typeof v !== 'undefined' ? v : CAN_NEVER_MATCH;\n}\nfunction replaceUndefinedValues(obj) {\n  return entries(obj)\n    .reduce((acc, [k, v]) => ({ ...acc, [k]: replaceUndefined(v) }), {});\n}\n\nexport function nodeMatchesObjectProps(node, props) {\n  return isSubset(propsOfNode(node), replaceUndefinedValues(props));\n}\n\nfunction getTextFromHostNode(hostNode) {\n  if (typeof hostNode === 'string') {\n    return String(hostNode || '');\n  }\n  if (!hostNode) {\n    return '';\n  }\n  return hostNode.textContent || '';\n}\n\nfunction getTextFromRSTNode(node, {\n  getCustom,\n  handleHostNodes,\n  recurse,\n  nullRenderReturnsNull = false,\n}) {\n  if (node == null) {\n    return '';\n  }\n\n  if (typeof node === 'string' || typeof node === 'number') {\n    return String(node);\n  }\n\n  if (getCustom && node.type && typeof node.type === 'function') {\n    return getCustom(node);\n  }\n\n  if (handleHostNodes && node.nodeType === 'host') {\n    return handleHostNodes(node);\n  }\n  if (node.rendered == null && nullRenderReturnsNull) {\n    return null;\n  }\n  return childrenOfNode(node).map(recurse).join('');\n}\n\nexport function getTextFromNode(node) {\n  return getTextFromRSTNode(node, {\n    recurse: getTextFromNode,\n    getCustom({ type }) {\n      return `<${type.displayName || functionName(type)} />`;\n    },\n  });\n}\n\nexport function getTextFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getTextFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getTextFromHostNode).join('');\n    },\n  });\n}\n\nfunction getHTMLFromHostNode(hostNode) {\n  if (hostNode == null) {\n    return null;\n  }\n  return hostNode.outerHTML.replace(/\\sdata-(reactid|reactroot)+=\"([^\"]*)+\"/g, '');\n}\n\nexport function getHTMLFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getHTMLFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getHTMLFromHostNode).join('');\n    },\n    nullRenderReturnsNull: true,\n  });\n}\n"]}