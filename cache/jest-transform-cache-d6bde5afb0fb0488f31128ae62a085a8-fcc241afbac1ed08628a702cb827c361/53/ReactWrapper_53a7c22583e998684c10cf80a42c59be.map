{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;AAEA;;AAeA;;;;AACA;;AACA;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,OAAO,gBAAI,UAAJ,CAAb;AACA,IAAMC,QAAQ,gBAAI,WAAJ,CAAd;AACA,IAAMC,WAAW,gBAAI,cAAJ,CAAjB;AACA,IAAMC,aAAa,gBAAI,gBAAJ,CAAnB;AACA,IAAMC,OAAO,gBAAI,UAAJ,CAAb;AACA,IAAMC,UAAU,gBAAI,aAAJ,CAAhB;AACA,IAAMC,aAAa,gBAAI,eAAJ,CAAnB;AACA,IAAMC,qBAAqB,gBAAI,uBAAJ,CAA3B;AACA,IAAMC,eAAe,gBAAI,iBAAJ,CAArB;AACA,IAAMC,aAAa,gBAAI,eAAJ,CAAnB;AAEA;;;;;;;;;;AASA,SAASC,kBAAT,CAA4BC,OAA5B,EAAqCC,SAArC,EAAqE;AAAA,MAArBC,MAAqB,uEAAZC,wBAAY;AACnE,SAAOH,QAAQI,OAARJ,CAAgB,UAACK,CAAD;AAAA,WAAOH,OAAOG,EAAEC,eAAFD,EAAPH,EAA4BD,SAA5BC,CAAP;AAAhB,IAAP;AACD;AAED;;;;;;;;;;AAQA,SAASK,oBAAT,CAA8BP,OAA9B,EAAuCC,SAAvC,EAAkD;AAChD,SAAOD,QAAQQ,IAARR,CAAaA,QAAQS,gBAART,GAA2BE,MAA3BF,CAAkCC,SAAlCD,EAA6CE,MAA7CF,CAAoDU,OAApDV,CAAbA,CAAP;AACD;;AAED,SAASW,mBAAT,CAA6BX,OAA7B,EAAsC;AACpC,MAAIA,QAAQP,IAARO,EAAcY,MAAdZ,KAAyB,CAA7B,EAAgC;AAC9B,UAAM,IAAIa,KAAJ,CAAU,6EAAV,CAAN;AACD;;AACD,MAAIb,QAAQP,IAARO,MAAkBA,OAAtB,EAA+B;AAC7B,WAAOA,QAAQL,UAARK,EAAoB,CAApBA,CAAP;AACD;;AACD,SAAOA,QAAQP,IAARO,EAAcX,IAAdW,CAAP;AACD;;AAED,SAASc,WAAT,CAAqBd,OAArB,EAA8Be,IAA9B,EAAoC;AAClC,SAAO,iCAAcA,IAAd,EAAoBJ,oBAAoBX,OAApBW,CAApB,CAAP;AACD;;AAED,SAASK,eAAT,CAAyBhB,OAAzB,EAAkCiB,KAAlC,EAAyC;AACvC,MAAI,CAACA,KAAL,EAAY;AACV,2BAAWjB,OAAX,EAAoBX,IAApB,EAA0B,IAA1B;AACA,2BAAWW,OAAX,EAAoBV,KAApB,EAA2B,EAA3B;AAFF,SAGO,IAAI,CAAC4B,MAAMC,OAAND,CAAcD,KAAdC,CAAL,EAA2B;AAChC,2BAAWlB,OAAX,EAAoBX,IAApB,EAA0B4B,KAA1B;AACA,2BAAWjB,OAAX,EAAoBV,KAApB,EAA2B,CAAC2B,KAAD,CAA3B;AAFK,SAGA;AACL,2BAAWjB,OAAX,EAAoBX,IAApB,EAA0B4B,MAAM,CAANA,CAA1B;AACA,2BAAWjB,OAAX,EAAoBV,KAApB,EAA2B2B,KAA3B;AACD;;AACD,yBAAWjB,OAAX,EAAoB,QAApB,EAA8BA,QAAQV,KAARU,EAAeY,MAA7C;AACD;AAED;;;;;IAGMQ,Y;AACJ,wBAAYH,KAAZ,EAAmBI,IAAnB,EAA6C;AAAA,QAApBC,aAAoB,uEAAJ,EAAI;;AAAAC;;AAC3C,QAAI,CAACC,OAAOC,MAAR,IAAkB,CAACD,OAAOE,QAA9B,EAAwC;AACtC,YAAM,IAAIb,KAAJ,CAAU,4EAAV,CAAN;AACD;;AACD,QAAMc,UAAU,wBAAYL,aAAZ,CAAhB;;AAEA,QAAI,CAACD,IAAL,EAAW;AACT,UAAMO,UAAU,6BAAWD,OAAX,CAAhB;;AACA,UAAI,CAACC,QAAQC,cAARD,CAAuBX,KAAvBW,CAAL,EAAoC;AAClC,cAAM,IAAIE,SAAJ,CAAc,2CAAd,CAAN;AACD;;AAED,UAAMC,WAAWH,QAAQI,cAARJ;AAAyBK,cAAM;AAA/B,SAA2CN,OAA3C,EAAjB;AACA,6BAAW,IAAX,EAAiBpC,QAAjB,EAA2BwC,QAA3B;AACAA,eAASG,MAATH,CAAgBd,KAAhBc,EAAuBJ,QAAQQ,OAA/BJ;AACA,6BAAW,IAAX,EAAiBtC,IAAjB,EAAuB,IAAvB;AACAuB,sBAAgB,IAAhBA,EAAsB,KAAKzB,QAAL,EAAe6C,OAAf,EAAtBpB;AACA,6BAAW,IAAX,EAAiBtB,OAAjB,EAA0BiC,OAA1B;AACA,6BAAW,IAAX,EAAiB9B,YAAjB,EAA+B,EAA/B;;AAEA,UAAI,8BAAkB8B,QAAQU,iBAA1B,EAA6CT,OAA7C,CAAJ,EAA2D;AACzD,YAAI,OAAO,KAAKrC,QAAL,EAAe+C,4BAAtB,KAAuD,UAA3D,EAAuE;AACrE,gBAAM,IAAIR,SAAJ,CAAc,sEAAd,CAAN;AACD,SAHwD,CAKzD;;;AACA,+BAAW,IAAX,EAAiBlC,kBAAjB,EAAqC,IAAI2C,wBAAJ,CACnC,IADmC,EAC7B,KAAKhD,QAAL,EAAe+C,4BAAf,EAD6B,CAArC;AAGA,aAAKzC,YAAL,EAAmB2C,IAAnB,CAAwB,KAAK5C,kBAAL,CAAxB;AACD;AAxBH,WAyBO;AACL,6BAAW,IAAX,EAAiBL,QAAjB,EAA2B8B,KAAK9B,QAAL8B,CAA3B;AACA,6BAAW,IAAX,EAAiB5B,IAAjB,EAAuB4B,IAAvB;AACAL,sBAAgB,IAAhBA,EAAsBC,KAAtBD;AACA,6BAAW,IAAX,EAAiBrB,UAAjB,EAA6B0B,KAAK/B,KAAL+B,CAA7B;AACA,6BAAW,IAAX,EAAiB3B,OAAjB,EAA0B2B,KAAK3B,OAAL2B,CAA1B;AACA,6BAAW,IAAX,EAAiBxB,YAAjB,EAA+B,EAA/B;AACD;;AACD,2BAAW,IAAX,EAAiBL,UAAjB,EAA6ByB,KAA7B;AACA,2BAAW,IAAX,EAAiBnB,UAAjB,EAA6B,IAA7B;AACD;AAED;;;;;;;;;;sBAKO;AACL,eAAO,KAAKL,IAAL,CAAP;AACD;;;;AAED;;;;;;;;;iCAKkB;AAChB,YAAI,KAAKmB,MAAL,KAAgB,CAApB,EAAuB;AACrB,gBAAM,IAAIC,KAAJ,CAAU,mEAAV,CAAN;AACD;;AACD,eAAO,KAAKvB,KAAL,EAAY,CAAZ,CAAP;AACD;;;;AAED;;;;;;;;;kCAKmB;AACjB,eAAO,KAAKA,KAAL,CAAP;AACD;;;;AAED;;;;;;;;;4BAKa;AAAA;;AACX,eAAO,KAAKmD,MAAL,CAAY,YAAZ,EAA0B;AAAA,iBAAM,6BAAWC,MAAKhD,OAAL,CAAX,EAA0BiD,aAA1B,CAAwCD,MAAKrD,IAAL,CAAxC,CAAN;AAA1B,UAAP;AACD;;;;AAED;;;;;;;;;6BAKc;AAAA;;AACZ,eAAO,KAAKC,KAAL,EAAYsD,GAAZ,CAAgB,UAACvC,CAAD;AAAA,iBAAO,6BAAWwC,OAAKnD,OAAL,CAAX,EAA0BiD,aAA1B,CAAwCtC,CAAxC,CAAP;AAAhB,UAAP;AACD;;;QAED;;;;;yBACU;AACR,cAAM,IAAIQ,KAAJ,CAAU,sFAAV,CAAN;AACD;;;QAED;;;;;0BACW;AACT,cAAM,IAAIA,KAAJ,CAAU,kDAAV,CAAN;AACD;;;;AAED;;;;;;;;;;;4BAOa;AACX,YAAMe,UAAU,6BAAW,KAAKlC,OAAL,CAAX,CAAhB;AACA,eAAO,KAAK+C,MAAL,CAAY,YAAZ,EAA0B,UAACpC,CAAD;AAAA,iBAAOuB,QAAQkB,cAARlB,CAAuBvB,CAAvBuB,EAA0B,IAA1BA,CAAP;AAA1B,UAAP;AACD;;;;AAED;;;;;;;;;;;;;mBASImB,SAAS;AACX,YAAI,KAAKtD,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,2DAAV,CAAN;AACD;;AACD,eAAO,KAAKmC,QAAL,GAAgBC,IAAhB,CAAqBF,OAArB,CAAP;AACD;;;;AAED;;;;;;;;;;;;;;;0BAWW;AAAA;;AACT,eAAO,KAAKN,MAAL,CAAY,UAAZ,EAAwB;AAAA,iBAAMS,OAAK7D,IAAL,EAAW2D,QAAjB;AAAxB,UAAP;AACD;;;;AAED;;;;;;;;;;;sCAOuB;AACrB,YAAI,KAAKvD,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,qEAAV,CAAN;AACD;;AACD,YAAI,CAAC,KAAKnB,OAAL,EAAc2C,iBAAnB,EAAsC;AACpC,gBAAM,IAAIxB,KAAJ,CAAU,8HAAV,CAAN;AACD;;AACD,eAAO,KAAKjB,kBAAL,CAAP;AACD;;;;AAED;;;;;;;;;;;;wBAQS;AAAA;;AACP,YAAMyB,OAAO,KAAK5B,IAAL,CAAb;;AACA,YAAI,SAAS4B,IAAb,EAAmB;AACjB,iBAAOA,KAAK8B,MAAL9B,EAAP;AACD;;AACDL,wBAAgB,IAAhBA,EAAsB,KAAKzB,QAAL,EAAe6C,OAAf,EAAtBpB;AACA,aAAKnB,YAAL,EAAmBuD,OAAnB,CAA2B,UAACC,UAAD,EAAgB;AACzC,cAAIA,eAAeC,OAAKxD,UAAL,CAAnB,EAAqC;AACnC;AACA;AACA;AACA;AACAuD,uBAAWvD,UAAXuD,IAAyBC,MAAzBD;;AACA,gBAAI;AACFA,yBAAWF,MAAXE;AADF,sBAEU;AACRA,yBAAWvD,UAAXuD,IAAyB,IAAzBA;AACD;AACF;AAZH;AAcA,eAAO,IAAP;AACD;;;;AAED;;;;;;;;;;yBAMU;AAAA;;AACR,YAAI,KAAK5D,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,wDAAV,CAAN;AACD;;AACD,aAAK4B,MAAL,CAAY,SAAZ,EAAuB,YAAM;AAC3Bc,iBAAKhE,QAAL,EAAeiE,OAAf;;AACAD,iBAAKJ,MAAL;AAFF;AAIA,eAAO,IAAP;AACD;;;;AAED;;;;;;;;;;;uBAOQ;AAAA;;AACN,YAAI,KAAK1D,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,sDAAV,CAAN;AACD;;AACD,aAAKtB,QAAL,EAAe2C,MAAf,CAAsB,KAAK1C,UAAL,CAAtB,EAAwC,KAAKE,OAAL,EAAcyC,OAAtD,EAA+D;AAAA,iBAAMsB,OAAKN,MAAL,EAAN;AAA/D;AACA,eAAO,IAAP;AACD;;;;AAED;;;;;;;;;;;;;;;;;;wBAcSO,OAA6B;AAAA;;AAAA,YAAtBC,QAAsB,uEAAXC,SAAW;;AACpC,YAAI,KAAKnE,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,yDAAV,CAAN;AACD;;AACD,YAAIgD,UAAUjD,MAAViD,GAAmB,CAAnBA,IAAwB,OAAOF,QAAP,KAAoB,UAAhD,EAA4D;AAC1D,gBAAM,IAAI7B,SAAJ,CAAc,oEAAd,CAAN;AACD;;AACD,YAAMF,UAAU,6BAAW,KAAKlC,OAAL,CAAX,CAAhB;AACA,aAAKF,UAAL,IAAmB,yBAAaoC,OAAb,EAAsB,KAAKpC,UAAL,CAAtB,EAAwCkE,KAAxC,CAAnB;AACA,aAAKnE,QAAL,EAAe2C,MAAf,CAAsB,KAAK1C,UAAL,CAAtB,EAAwC,IAAxC,EAA8C,YAAM;AAClDsE,iBAAKX,MAAL;;AACA,cAAIQ,QAAJ,EAAc;AACZA;AACD;AAJH;AAMA,eAAO,IAAP;AACD;;;;AAED;;;;;;;;;;;;;;;;;wBAaSI,OAA6B;AAAA;;AAAA,YAAtBJ,QAAsB,uEAAXC,SAAW;;AACpC,YAAI,KAAKZ,QAAL,OAAoB,IAApB,IAA4B,KAAK1C,eAAL,GAAuB0D,QAAvB,KAAoC,OAApE,EAA6E;AAC3E,gBAAM,IAAInD,KAAJ,CAAU,iEAAV,CAAN;AACD;;AACD,YAAIgD,UAAUjD,MAAViD,GAAmB,CAAnBA,IAAwB,OAAOF,QAAP,KAAoB,UAAhD,EAA4D;AAC1D,gBAAM,IAAI7B,SAAJ,CAAc,oEAAd,CAAN;AACD;;AACD,aAAKkB,QAAL,GAAgBiB,QAAhB,CAAyBF,KAAzB,EAAgC,YAAM;AACpCG,iBAAKf,MAAL;;AACA,cAAIQ,QAAJ,EAAc;AACZ,gBAAM/B,UAAU,6BAAWsC,OAAKxE,OAAL,CAAX,CAAhB;;AACA,gBAAMsD,WAAWkB,OAAKlB,QAAL,EAAjB;;AACA,gBAAIpB,QAAQuC,sBAAZ,EAAoC;AAClCvC,sBAAQuC,sBAARvC,CAA+BoB,QAA/BpB,EAAyC+B,QAAzC/B;AADF,mBAEO;AACL+B,uBAASS,IAATT,CAAcX,QAAdW;AACD;AACF;AAVH;AAYA,eAAO,IAAP;AACD;;;;AAED;;;;;;;;;;;;;0BASWxB,SAAS;AAAA;;AAClB,YAAI,KAAK1C,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,2DAAV,CAAN;AACD;;AACD,YAAI,CAAC,KAAKnB,OAAL,EAAcyC,OAAnB,EAA4B;AAC1B,gBAAM,IAAItB,KAAJ,CAAU,wGAAV,CAAN;AACD;;AACD,aAAKtB,QAAL,EAAe2C,MAAf,CAAsB,KAAK1C,UAAL,CAAtB,EAAwC2C,OAAxC,EAAiD;AAAA,iBAAMkC,OAAKlB,MAAL,EAAN;AAAjD;AACA,eAAO,IAAP;AACD;;;;AAED;;;;;;;;;;;;;;;;wBAYSmB,aAAa;AACpB,YAAM1C,UAAU,6BAAW,KAAKlC,OAAL,CAAX,CAAhB;AAEA,YAAMO,YAAYiB,MAAMC,OAAND,CAAcoD,WAAdpD,IACd,UAACqD,KAAD;AAAA,iBAAW,qCACXC,gBADW,EAEXD,KAFW,EAGXD,YAAY1B,GAAZ0B,CAAgB,UAACvD,IAAD;AAAA,mBAAUa,QAAQ6C,aAAR7C,CAAsBb,IAAtBa,CAAV;AAAhB,YAHW,CAAX;AADc,YAMd,UAAC2C,KAAD;AAAA,iBAAW,sBAAU3C,QAAQ6C,aAAR7C,CAAsB0C,WAAtB1C,CAAV,EAA8C2C,KAA9C,CAAX;AANJ;AAQA,eAAOxE,mBAAmB,IAAnBA,EAAyBE,SAAzBF,EAAoCa,MAApCb,GAA6C,CAApD;AACD;;;;AAED;;;;;;;;;;;;;;;;;;;;uCAgBwBgB,MAAM;AAC5B,YAAM2D,UAAU,6BAAW,KAAKhF,OAAL,CAAX,EAA0B+E,aAA1B,CAAwC1D,IAAxC,CAAhB;;AACA,YAAMd;AAAY,mBAAZA,SAAY,CAACsE,KAAD;AAAA,mBAAW,wBAAYG,OAAZ,EAAqBH,KAArB,EAA4B,UAACI,CAAD,EAAIC,CAAJ;AAAA,qBAAUD,KAAKC,CAAf;AAA5B,cAAX;AAAA;;AAAZ;AAAA,WAAN;;AACA,eAAO7E,mBAAmB,IAAnBA,EAAyBE,SAAzBF,EAAoCa,MAApCb,GAA6C,CAApD;AACD;;;;AAED;;;;;;;;;;;;;;;;;;;;;;2CAkB4BkB,OAAO;AAAA;;AACjC,YAAI,CAACC,MAAMC,OAAND,CAAcD,KAAdC,CAAL,EAA2B;AACzB,gBAAM,IAAIY,SAAJ,CAAc,0BAAd,CAAN;AACD;;AAED,eAAOb,MAAM4D,KAAN5D,CAAY,UAACF,IAAD;AAAA,iBAAU+D,QAAKC,uBAAL,CAA6BhE,IAA7B,CAAV;AAAZ,UAAP;AACD;;;;AAED;;;;;;;;;;;;;;;;;;;;;;2CAkB4BE,OAAO;AAAA;;AACjC,eAAOC,MAAMC,OAAND,CAAcD,KAAdC,KAAwBD,MAAM+D,IAAN/D,CAAW,UAACF,IAAD;AAAA,iBAAUkE,QAAKF,uBAAL,CAA6BhE,IAA7B,CAAV;AAAX,UAA/B;AACD;;;;AAED;;;;;;;;;;;;;;;;sBAYOA,MAAM;AAAA;;AACX,eAAO,KAAK0B,MAAL,CAAY,QAAZ,EAAsB;AAAA,iBAAM,sBAAUyC,QAAK5E,eAAL,EAAV,EAAkCS,IAAlC,CAAN;AAAtB,UAAP;AACD;;;;AAED;;;;;;;;;;;;;;;;;;;;;8BAiBeA,MAAM;AAAA;;AACnB,eAAO,KAAK0B,MAAL,CAAY,gBAAZ,EAA8B,YAAM;AACzC,cAAMb,UAAU,6BAAWuD,QAAKzF,OAAL,CAAX,CAAhB;AACA,cAAMgF,UAAU9C,QAAQ6C,aAAR7C,CAAsBb,IAAtBa,CAAhB;AACA,iBAAO,wBAAY8C,OAAZ,EAAqBS,QAAK7E,eAAL,EAArB,EAA6C,UAACqE,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,KAAKC,CAAf;AAA7C,YAAP;AAHK,UAAP;AAKD;;;;AAED;;;;;;;;;;oBAMKQ,UAAU;AACb,eAAO,KAAK5E,IAAL,CAAU,sCAAsB4E,QAAtB,EAAgC,KAAK3E,gBAAL,EAAhC,CAAV,CAAP;AACD;;;;AAED;;;;;;;;;;;;kBAQG2E,UAAU;AACX,YAAMnF,YAAY,+BAAemF,QAAf,CAAlB;AACA,eAAO,KAAK3C,MAAL,CAAY,IAAZ,EAAkB,UAACpC,CAAD;AAAA,iBAAOJ,UAAUI,CAAVJ,CAAP;AAAlB,UAAP;AACD;;;;AAED;;;;;;;;;+BAKgB;AACd,YAAMgB,QAAQ,KAAKX,eAAL,EAAd;AAEA,eAAO,yBAAaW,KAAb,CAAP;AACD;;;;AAED;;;;;;;;;;;2BAOYhB,WAAW;AAAA;;AACrB,eAAOM,qBAAqB,IAArBA,EAA2B,UAACF,CAAD;AAAA,iBAAOJ,UAAUoF,QAAK7E,IAAL,CAAUH,CAAV,CAAVJ,CAAP;AAA3B,UAAP;AACD;;;;AAED;;;;;;;;;;;sBAOOmF,UAAU;AACf,YAAMnF,YAAY,+BAAemF,QAAf,CAAlB;AACA,eAAO7E,qBAAqB,IAArBA,EAA2BN,SAA3BM,CAAP;AACD;;;;AAED;;;;;;;;;;;mBAOI6E,UAAU;AACZ,YAAMnF,YAAY,+BAAemF,QAAf,CAAlB;AACA,eAAO7E,qBAAqB,IAArBA,EAA2B,UAACF,CAAD;AAAA,iBAAO,CAACJ,UAAUI,CAAVJ,CAAR;AAA3B,UAAP;AACD;;;;AAED;;;;;;;;;;;;;sBASO;AACL,YAAM2B,UAAU,6BAAW,KAAKlC,OAAL,CAAX,CAAhB;AACA,eAAO,KAAK+C,MAAL,CAAY,MAAZ,EAAoB,UAACpC,CAAD;AAAA,iBAAO,wCAAqBA,CAArB,EAAwBuB,OAAxB,CAAP;AAApB,UAAP;AACD;;;;AAED;;;;;;;;;;;sBAOO;AACL,YAAMA,UAAU,6BAAW,KAAKlC,OAAL,CAAX,CAAhB;AACA,eAAO,KAAK+C,MAAL,CAAY,MAAZ,EAAoB,UAACpC,CAAD;AAAA,iBAAO,wCAAqBA,CAArB,EAAwBuB,OAAxB,CAAP;AAApB,UAAP;AACD;;;;AAED;;;;;;;;;;;wBAOS;AACP,YAAM0D,OAAO,KAAKA,IAAL,EAAb;AACA,eAAO,4BAAgBA,IAAhB,CAAP;AACD;;;;AAED;;;;;;;;;;;;wBAQSC,OAAkB;AAAA;;AAAA,YAAXC,IAAW,uEAAJ,EAAI;AACzB,eAAO,KAAK/C,MAAL,CAAY,UAAZ,EAAwB,UAACpC,CAAD,EAAO;AACpCoF,kBAAKlG,QAAL,EAAemG,aAAf,CAA6BrF,CAA7B,EAAgCkF,KAAhC,EAAuCC,IAAvC;;AACAC,kBAAKhG,IAAL,EAAW0D,MAAX;;AACA,iBAAOsC,OAAP;AAHK,UAAP;AAKD;;;;AAED;;;;;;;;;;6BAMcE,OAAO;AAAA;;AACnB,YAAI,KAAKlG,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,6DAAV,CAAN;AACD;;AAED,eAAO,KAAK4B,MAAL,CAAY,eAAZ,EAA6B,UAACmD,QAAD,EAAc;AAChD,cAAIA,SAAS5B,QAAT4B,KAAsB,MAA1B,EAAkC;AAChC,kBAAM,IAAI/E,KAAJ,CAAU,uEAAV,CAAN;AACD;;AAED,cAAMkB,WAAW8D,QAAKtG,QAAL,CAAjB;;AACA,cAAI,OAAOwC,SAAS+D,aAAhB,KAAkC,UAAtC,EAAkD;AAChD,kBAAM,IAAIhE,SAAJ,CAAc,kEAAd,CAAN;AACD;;AAED,cAAMiE,WAAWpF,oBAAoBkF,OAApBlF,CAAjB;AACA,cAAMqF,gBAAgB,CAACJ,QAAD,EAAWK,MAAX,CAAkBnF,YAAY+E,OAAZ/E,EAAkB8E,QAAlB9E,CAAlB,CAAtB;AACAiB,mBAAS+D,aAAT/D,CAAuBiE,aAAvBjE,EAAsCgE,QAAtChE,EAAgD4D,KAAhD5D;;AAEA8D,kBAAKpG,IAAL,EAAW0D,MAAX;;AACA,iBAAO0C,OAAP;AAfK,UAAP;AAiBD;;;;AAED;;;;;;;;;;;uBAOQ;AACN,eAAO,KAAKpD,MAAL,CAAY,OAAZ,EAAqByD,yBAArB,CAAP;AACD;;;;AAED;;;;;;;;;;;;;qBASMC,MAAM;AAAA;;AACV,YAAMP,WAAW,KAAKnG,IAAL,MAAe,IAAf,GAAsB,KAAKF,QAAL,EAAe6C,OAAf,EAAtB,GAAiD,KAAK9B,eAAL,EAAlE;;AACA,YAAI,KAAK0C,QAAL,OAAoB,IAApB,IAA4B4C,SAAS5B,QAAT4B,KAAsB,OAAtD,EAA+D;AAC7D,gBAAM,IAAI/E,KAAJ,CAAU,8DAAV,CAAN;AACD;;AACD,YAAMuF,SAAS,KAAK3D,MAAL,CAAY,OAAZ,EAAqB;AAAA,iBAAM4D,QAAKrD,QAAL,GAAgBe,KAAtB;AAArB,UAAf;;AACA,YAAI,OAAOoC,IAAP,KAAgB,WAApB,EAAiC;AAC/B,cAAIC,UAAU,IAAd,EAAoB;AAClB,kBAAM,IAAItE,SAAJ,kCAAsCqE,IAAtC,4DAAN;AACD;;AACD,iBAAOC,OAAOD,IAAPC,CAAP;AACD;;AACD,eAAOA,MAAP;AACD;;;;AAED;;;;;;;;;;;;;uBASQD,MAAM;AAAA;;AACZ,YAAI,KAAK1G,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,wDAAV,CAAN;AACD;;AACD,YAAMmC,WAAW,KAAKP,MAAL,CAAY,SAAZ,EAAuB;AAAA,iBAAM6D,QAAKtD,QAAL,EAAN;AAAvB,UAAjB;;AACA,YAAIA,aAAa,IAAjB,EAAuB;AACrB,gBAAM,IAAInC,KAAJ,CAAU,yEAAV,CAAN;AACD;;AACD,YAAM0F,WAAWvD,SAASb,OAA1B;;AACA,YAAI,OAAOgE,IAAP,KAAgB,WAApB,EAAiC;AAC/B,iBAAOI,SAASJ,IAATI,CAAP;AACD;;AACD,eAAOA,QAAP;AACD;;;;AAED;;;;;;;;;;wBAMSnB,UAAU;AACjB,YAAMoB,cAAc,KAAKpG,OAAL,CAAa,UAACC,CAAD;AAAA,iBAAO,kCAAeA,EAAEC,eAAFD,EAAf,CAAP;AAAb,UAApB;AACA,eAAO+E,WAAWoB,YAAYtG,MAAZsG,CAAmBpB,QAAnBoB,CAAXpB,GAA0CoB,WAAjD;AACD;;;;AAED;;;;;;;;;;uBAMQC,OAAO;AAAA;;AACb,eAAO,KAAKhE,MAAL,CAAY,SAAZ,EAAuB;AAAA,iBAAMiE,QAAKC,QAAL,GAAgBC,EAAhB,CAAmBH,KAAnB,CAAN;AAAvB,UAAP;AACD;;;;AAED;;;;;;;;;;;;;uBASQrB,UAAU;AAAA;;AAChB,eAAO,KAAK3C,MAAL,CAAY,SAAZ,EAAuB,UAACpC,CAAD,EAAO;AACnC,cAAMwG,aAAaC,QAAKtG,IAAL,CAAUM,YAAYgG,OAAZhG,EAAkBT,CAAlBS,CAAV,CAAnB;;AACA,iBAAOsE,WAAWyB,WAAW3G,MAAX2G,CAAkBzB,QAAlByB,CAAXzB,GAAyCyB,UAAhD;AAFK,UAAP;AAID;;;;AAED;;;;;;;;;wBAKS;AACP,eAAO,KAAKzG,OAAL,CAAa,UAACC,CAAD;AAAA,iBAAO,CAACA,EAAE0G,OAAF1G,GAAY2G,GAAZ3G,CAAgB,CAAhBA,CAAD,CAAP;AAAb,UAAP;AACD;;;;AAED;;;;;;;;;uBAKQ+E,UAAU;AAChB,YAAI,KAAK6B,EAAL,CAAQ7B,QAAR,CAAJ,EAAuB;AACrB,iBAAO,IAAP;AACD;;AACD,YAAM8B,oBAAoB,KAAKH,OAAL,GAAe7G,MAAf,CAAsBkF,QAAtB,CAA1B;AACA,eAAO8B,kBAAkBtG,MAAlBsG,GAA2B,CAA3BA,GAA+BA,kBAAkBC,KAAlBD,EAA/BA,GAA2D,KAAKE,SAAL,CAAe;AAAA,iBAAM,KAAN;AAAf,UAAlE;AACD;;;;AAED;;;;;;;;;;oBAMKC,UAAU;AACb,eAAO,KAAK3D,KAAL,GAAa2D,QAAb,CAAP;AACD;;;;AAED;;;;;;;;;;;sBAOOA,UAAU;AAAA;;AACf,eAAO,KAAK5E,MAAL,CAAY,QAAZ,EAAsB,YAAM;AACjC,cAAM6E,UAAUC,QAAKC,IAAL,CAAUH,QAAV,CAAhB;;AACA,cAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC;AACjC,kBAAM,IAAIxF,SAAJ,CAAc,8EAAd,CAAN;AACD;;AACD,iBAAO,YAAa;AAAA,8CAAT2F,IAAS;AAATA,kBAAS,MAATA,GAAS5D,eAAT4D;AAAS;;AAClB,gBAAMC,WAAW,OAAOH,QAAKhI,QAAL,EAAeoI,UAAtB,KAAqC,UAArC,GACbJ,QAAKhI,QAAL,EAAeoI,UAAf,CAA0B;AAAA,qBAAML,yBAAWG,IAAXH,CAAN;AAA1B,cADa,GAEbA,yBAAWG,IAAXH,CAFJ;;AAGAC,oBAAK9H,IAAL,EAAW0D,MAAX;;AACA,mBAAOuE,QAAP;AALF;AALK,UAAP;AAaD;;;;AAED;;;;;;;;;;0BAMWL,UAAU;AAAA;;AACnB,YAAMzF,UAAU,6BAAW,KAAKlC,OAAL,CAAX,CAAhB;;AACA,YAAI,OAAOkC,QAAQpB,IAAf,KAAwB,UAA5B,EAAwC;AACtC,gBAAM,IAAIoH,UAAJ,CAAe,yDAAf,CAAN;AACD;;AAED,eAAO,KAAKnF,MAAL,CAAY,YAAZ,EAA0B,UAACpC,CAAD,EAAO;AACtC,cAAIA,EAAE2D,QAAF3D,KAAe,MAAnB,EAA2B;AACzB,kBAAM,IAAIyB,SAAJ,CAAc,oEAAd,CAAN;AACD;;AACD,cAAI,OAAOuF,QAAP,KAAoB,QAAxB,EAAkC;AAChC,kBAAM,IAAIvF,SAAJ,CAAc,yDAAd,CAAN;AACD;;AACD,cAAM4B,QAAQmE,QAAKnE,KAAL,EAAd;;AACA,cAAI,CAAC,sBAAIA,KAAJ,EAAW2D,QAAX,CAAL,EAA2B;AACzB,kBAAM,IAAIxG,KAAJ,8DAAyDwG,QAAzD,mBAAN;AACD;;AACD,cAAMS,YAAYpE,MAAM2D,QAAN3D,CAAlB;;AACA,cAAI,OAAOoE,SAAP,KAAqB,UAAzB,EAAqC;AACnC,kBAAM,IAAIhG,SAAJ,6DAA4DuF,QAA5D,kEAAqHS,SAArH,yCAAqHA,SAArH,cAAN;AACD;;AAED,iBAAO,YAAa;AAClB,gBAAMC,UAAUD,qCAAhB;AACA,gBAAME,UAAUpG,QAAQpB,IAARoB,CAAamG,OAAbnG,CAAhB;AACA,mBAAOiG,QAAKrH,IAAL,CAAUwH,OAAV,EAAmB,IAAnB,EAAyBH,QAAKnI,OAAL,CAAzB,CAAP;AAHF;AAhBK,UAAP;AAsBD;;;;AAED;;;;;;;;;qBAKM;AACJ,eAAO,KAAK+C,MAAL,CAAY,KAAZ,EAAmB,UAACpC,CAAD;AAAA,iBAAQA,EAAE4H,GAAF5H,KAAUuD,SAAVvD,GAAsB,IAAtBA,GAA6BA,EAAE4H,GAAvC;AAAnB,UAAP;AACD;;;;AAED;;;;;;;;;;sBAMO;AACL,eAAO,KAAKxF,MAAL,CAAY,MAAZ,EAAoB,UAACpC,CAAD;AAAA,iBAAO,uBAAWA,CAAX,CAAP;AAApB,UAAP;AACD;;;;AAED;;;;;;;;;;;sBAOO;AACL,YAAMuB,UAAU,6BAAW,KAAKlC,OAAL,CAAX,CAAhB;AACA,eAAO,KAAK+C,MAAL,CAAY,MAAZ,EAAoB,UAACpC,CAAD;AAAA,iBACzBuB,QAAQsG,iBAARtG,GAA4BA,QAAQsG,iBAARtG,CAA0BvB,CAA1BuB,CAA5BA,GAA2D,8BAAkBvB,CAAlB,CADlC;AAApB,UAAP;AAGD;;;;AAED;;;;;;;;;;;;wBAQS8H,WAAW;AAClB,YAAI,OAAOA,SAAP,KAAqB,QAArB,IAAiCA,UAAUC,OAAVD,CAAkB,GAAlBA,MAA2B,CAAC,CAAjE,EAAoE;AAClE;AACAE,kBAAQC,IAARD,CAAa,oIAAbA;AACD;;AACD,eAAO,KAAK5F,MAAL,CAAY,UAAZ,EAAwB,UAACpC,CAAD;AAAA,iBAAO,gCAAaA,CAAb,EAAgB8H,SAAhB,CAAP;AAAxB,UAAP;AACD;;;;AAED;;;;;;;;;;;uBAOQI,IAAI;AAAA;;AACV,aAAK9H,gBAAL,GAAwB2C,OAAxB,CAAgC,UAAC/C,CAAD,EAAImI,CAAJ;AAAA,iBAAUD,GAAGnE,IAAHmE,CAAQE,OAARF,EAAcE,QAAKjI,IAAL,CAAUH,CAAV,CAAdkI,EAA4BC,CAA5BD,CAAV;AAAhC;AACA,eAAO,IAAP;AACD;;;;AAED;;;;;;;;;;;mBAOIA,IAAI;AAAA;;AACN,eAAO,KAAK9H,gBAAL,GAAwBmC,GAAxB,CAA4B,UAACvC,CAAD,EAAImI,CAAJ;AAAA,iBAAUD,GAAGnE,IAAHmE,CAAQG,OAARH,EAAcG,QAAKlI,IAAL,CAAUH,CAAV,CAAdkI,EAA4BC,CAA5BD,CAAV;AAA5B,UAAP;AACD;;;;AAED;;;;;;;;;;;;sBAQOA,IAA8B;AAAA;;AAAA,YAA1BI,YAA0B,uEAAX/E,SAAW;;AACnC,YAAIC,UAAUjD,MAAViD,GAAmB,CAAvB,EAA0B;AACxB,iBAAO,KAAKpD,gBAAL,GAAwBmI,MAAxB,CACL,UAACC,KAAD,EAAQxI,CAAR,EAAWmI,CAAX;AAAA,mBAAiBD,GAAGnE,IAAHmE,CAAQO,OAARP,EAAcM,KAAdN,EAAqBO,QAAKtI,IAAL,CAAUH,CAAV,CAArBkI,EAAmCC,CAAnCD,CAAjB;AADK,aAELI,YAFK,CAAP;AAID;;AACD,eAAO,KAAKlI,gBAAL,GAAwBmI,MAAxB,CAA+B,UAACC,KAAD,EAAQxI,CAAR,EAAWmI,CAAX;AAAA,iBAAiBD,GAAGnE,IAAHmE,CACrDO,OADqDP,EAErDC,MAAM,CAANA,GAAUM,QAAKtI,IAAL,CAAUqI,KAAV,CAAVL,GAA6BK,KAFwBN,EAGrDO,QAAKtI,IAAL,CAAUH,CAAV,CAHqDkI,EAIrDC,CAJqDD,CAAjB;AAA/B,UAAP;AAMD;;;;AAED;;;;;;;;;;;;2BAQYA,IAA8B;AAAA;;AAAA,YAA1BI,YAA0B,uEAAX/E,SAAW;;AACxC,YAAIC,UAAUjD,MAAViD,GAAmB,CAAvB,EAA0B;AACxB,iBAAO,KAAKpD,gBAAL,GAAwBsI,WAAxB,CACL,UAACF,KAAD,EAAQxI,CAAR,EAAWmI,CAAX;AAAA,mBAAiBD,GAAGnE,IAAHmE,CAAQS,OAART,EAAcM,KAAdN,EAAqBS,QAAKxI,IAAL,CAAUH,CAAV,CAArBkI,EAAmCC,CAAnCD,CAAjB;AADK,aAELI,YAFK,CAAP;AAID;;AACD,eAAO,KAAKlI,gBAAL,GAAwBsI,WAAxB,CAAoC,UAACF,KAAD,EAAQxI,CAAR,EAAWmI,CAAX;AAAA,iBAAiBD,GAAGnE,IAAHmE,CAC1DS,OAD0DT,EAE1DC,MAAM,CAANA,GAAUQ,QAAKxI,IAAL,CAAUqI,KAAV,CAAVL,GAA6BK,KAF6BN,EAG1DS,QAAKxI,IAAL,CAAUH,CAAV,CAH0DkI,EAI1DC,CAJ0DD,CAAjB;AAApC,UAAP;AAMD;;;;AAED;;;;;;;;;;;;qBAQMU,OAAOC,KAAK;AAChB,eAAO,KAAK1I,IAAL,CAAU,KAAKC,gBAAL,GAAwB0I,KAAxB,CAA8BF,KAA9B,EAAqCC,GAArC,CAAV,CAAP;AACD;;;;AAED;;;;;;;;;;oBAMK9D,UAAU;AACb,YAAI,KAAK3F,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,oDAAV,CAAN;AACD;;AACD,YAAMZ,YAAY,+BAAemF,QAAf,CAAlB;AACA,eAAO,KAAK3E,gBAAL,GAAwBuE,IAAxB,CAA6B/E,SAA7B,CAAP;AACD;;;;AAED;;;;;;;;;;yBAMUA,WAAW;AAAA;;AACnB,eAAO,KAAKQ,gBAAL,GAAwBuE,IAAxB,CAA6B,UAAC3E,CAAD,EAAImI,CAAJ;AAAA,iBAAUvI,UAAUmE,IAAVnE,CAAemJ,OAAfnJ,EAAqBmJ,QAAK5I,IAAL,CAAUH,CAAV,CAArBJ,EAAmCuI,CAAnCvI,CAAV;AAA7B,UAAP;AACD;;;;AAED;;;;;;;;;;qBAMMmF,UAAU;AACd,YAAMnF,YAAY,+BAAemF,QAAf,CAAlB;AACA,eAAO,KAAK3E,gBAAL,GAAwBoE,KAAxB,CAA8B5E,SAA9B,CAAP;AACD;;;;AAED;;;;;;;;;;0BAMWA,WAAW;AAAA;;AACpB,eAAO,KAAKQ,gBAAL,GAAwBoE,KAAxB,CAA8B,UAACxE,CAAD,EAAImI,CAAJ;AAAA,iBAAUvI,UAAUmE,IAAVnE,CAAeoJ,OAAfpJ,EAAqBoJ,QAAK7I,IAAL,CAAUH,CAAV,CAArBJ,EAAmCuI,CAAnCvI,CAAV;AAA9B,UAAP;AACD;;;;AAED;;;;;;;;;;;;uBAQQsI,IAAI;AAAA;;AACV,YAAMtH,QAAQ,KAAKR,gBAAL,GAAwBmC,GAAxB,CAA4B,UAACvC,CAAD,EAAImI,CAAJ;AAAA,iBAAUD,GAAGnE,IAAHmE,CAAQe,OAARf,EAAce,QAAK9I,IAAL,CAAUH,CAAV,CAAdkI,EAA4BC,CAA5BD,CAAV;AAA5B,UAAd;AACA,YAAMgB,YAAY,iCAAKtI,KAAL,EAAY,CAAZ,CAAlB;AACA,eAAO,KAAKT,IAAL,CAAU+I,UAAUrJ,MAAVqJ,CAAiB7I,OAAjB6I,CAAV,CAAP;AACD;;;;AAED;;;;;;;;;;;yBAOUtJ,WAAW;AAAA;;AACnB,eAAOF,mBAAmB,IAAnBA,EAAyB,UAACM,CAAD,EAAO;AACrC,cAAMU,OAAOyI,QAAKhJ,IAAL,CAAUH,CAAV,CAAb;;AACA,iBAAOU,KAAKH,MAALG,GAAc,CAAdA,IAAmBd,UAAUc,IAAVd,CAA1B;AAFK,UAAP;AAID;;;;AAED;;;;;;;;;;mBAMIwG,OAAO;AACT,eAAO,KAAKgD,WAAL,GAAmBhD,KAAnB,CAAP;AACD;;;;AAED;;;;;;;;;;kBAMGA,OAAO;AACR,YAAMxF,QAAQ,KAAKR,gBAAL,EAAd;;AACA,YAAIgG,QAAQxF,MAAML,MAAlB,EAA0B;AACxB,iBAAO,KAAKJ,IAAL,CAAUS,MAAMwF,KAANxF,CAAV,CAAP;AACD;;AACD,eAAO,KAAKT,IAAL,CAAU,EAAV,CAAP;AACD;;;;AAED;;;;;;;;;uBAKQ;AACN,eAAO,KAAKoG,EAAL,CAAQ,CAAR,CAAP;AACD;;;;AAED;;;;;;;;;sBAKO;AACL,eAAO,KAAKA,EAAL,CAAQ,KAAKhG,MAAL,GAAc,CAAtB,CAAP;AACD;;;;AAED;;;;;;;;;yBAKU;AACR;AACAyH,gBAAQC,IAARD,CAAa,mEAAbA;AACA,eAAO,CAAC,KAAKqB,MAAL,EAAR;AACD;;;;AAED;;;;;;;;;;;wBAOwB;AAAA,YAAjBtE,QAAiB,uEAAN,IAAM;AACtB,eAAOvB,UAAUjD,MAAViD,GAAmB,CAAnBA,GAAuB,KAAK8F,IAAL,CAAUvE,QAAV,EAAoBsE,MAApB,EAAvB7F,GAAsD,KAAKjD,MAAL,GAAc,CAA3E;AACD;;;;AAED;;;;;;;;;;;;sBAQOuF,MAAMoC,IAAI;AACf,YAAMqB,SAAS,OAAOzD,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkC,SAAjD;AACA,YAAMxC,WAAW,OAAO4E,EAAP,KAAc,UAAd,GAA2BA,EAA3B,GAAgCpC,IAAjD;;AACA,YAAI,KAAKvF,MAAL,KAAgB,CAApB,EAAuB;AACrB,gBAAM,IAAIC,KAAJ,mBAAqB+I,MAArB,oDAA8D,KAAKhJ,MAAnE,sBAAN;AACD;;AACD,eAAO+C,SAASS,IAATT,CAAc,IAAdA,EAAoB,KAAKrD,eAAL,EAApBqD,CAAP;AACD;;;;AAED;;;;;;;;;;;oBAOK5C,MAAkC;AAAA,YAA5BM,IAA4B,uEAArB,KAAK5B,IAAL,CAAqB;;AACrC,YAAIsB,gBAAgBK,YAApB,EAAkC;AAChC,iBAAOL,IAAP;AACD;;AAHoC,2CAAN0G,IAAM;AAANA,cAAM,WAANA,GAAM5D,gBAAN4D;AAAM;;AAIrC,kDAAWrG,YAAX,iBAAwBL,IAAxB,EAA8BM,IAA9B,GAAuCoG,IAAvC;AACD;;;;AAED;;;;;;;;;;;;uBAQoB;AAAA,YAAd9F,OAAc,uEAAJ,EAAI;AAClB,eAAO,uBAAW,KAAKlB,gBAAL,EAAX,EAAoCkB,OAApC,CAAP;AACD;;;;AAED;;;;;;;;;;mBAMIkI,aAAa;AACfA,oBAAY,IAAZA;AACA,eAAO,IAAP;AACD;;;;AAED;;;;;;;;;;;;;wBASS;AACP,YAAI,KAAKpK,IAAL,MAAe,IAAnB,EAAyB;AACvB,gBAAM,IAAIoB,KAAJ,CAAU,uDAAV,CAAN;AACD;;AACD,YAAI,CAAC,KAAKnB,OAAL,EAAcoK,QAAnB,EAA6B;AAC3B,gBAAM,IAAIjJ,KAAJ,CAAU,oGAAV,CAAN;AACD;;AACD,aAAKtB,QAAL,EAAeiE,OAAf;AACD;;;;AAED;;;;;;;;;;2BAMY;AACV,eAAO,KAAKuG,WAAL,CAAiB,UAAC1J,CAAD;AAAA,iBAAO,OAAOA,EAAE2J,IAAF3J,EAAP,KAAoB,QAA3B;AAAjB,UAAP;AACD;;;;;;;;AAGH;;;;;;;;;IAOMkC,wB;;AACJ;;;AACA,oCAAYlB,IAAZ,EAAkBU,QAAlB,EAA4B;AAAAR;;AAAA,sJACpBQ,SAASK,OAATL,EADoB,EACAV,IADA;;AAG1B,oCAAiB5B,IAAjB;AACA,oCAAiBF,QAAjB,EAA2BwC,QAA3B;;AACAkI,YAAKpK,YAAL,EAAmB2C,IAAnB,CAAwBnB,IAAxB;;AAL0B;AAM3B;;;;;sCAEsB;AACrB,cAAM,IAAIS,SAAJ,CAAc,qEAAd,CAAN;AACD;;;;;;;EAZoCV,Y;;AAevC,IAAI8I,sBAAJ,EAAqB;AACnBC,SAAOC,cAAPD,CAAsB/I,aAAaiJ,SAAnCF,EAA8CD,sBAA9CC,EAA+D;AAC7DG,kBAAc,IAD+C;AAE7DC;AAAO,eAASC,QAAT,GAAoB;AAAA;;AACzB,YAAMC,OAAO,KAAKnL,KAAL,EAAY4K,sBAAZ,GAAb;;AACA,YAAMtI,UAAU,6BAAW,KAAKlC,OAAL,CAAX,CAAhB;AACA,gDACGwK,sBADH,cACsB;AAAE,iBAAO,IAAP;AADxB;AAAA,0BAES;AACL,gBAAMQ,OAAOD,KAAKC,IAALD,EAAb;;AACA,gBAAIC,KAAKC,IAAT,EAAe;AACb,qBAAO;AAAEA,sBAAM;AAAR,eAAP;AACD;;AACD,mBAAO;AACLA,oBAAM,KADD;AAELJ,qBAAO3I,QAAQe,aAARf,CAAsB8I,KAAKH,KAA3B3I;AAFF,aAAP;AAID;;AAXH;AAAA;AAaD;;AAhBD,aAAgB4I,QAAhB;AAAA;AAF6D,GAA/DL;AAoBD;;AAED,SAASS,cAAT,CAAwBpD,IAAxB,EAA8BqD,YAA9B,EAA4C;AAC1CV,SAAOC,cAAPD,CAAsB/I,aAAaiJ,SAAnCF,EAA8C3C,IAA9C2C,EAAoD;AAClDnD,OADkD;AAAA,qBAC5C;AACJ,cAAM,IAAInG,KAAJ,yDACgC2G,IADhC,8JAGFqD,YAHE,eAAN;AAKD;;AAPiD;AAAA;AAQlDC,gBAAY,KARsC;AASlDR,kBAAc;AAToC,GAApDH;AAWD;;AAEDS,eAAe,MAAfA,EAAuB,iDAAvBA;AACAA,eAAe,OAAfA,EAAwB,kDAAxBA;AACAA,eAAe,UAAfA,EAA2B,EAA3BA;AACAA,eAAe,SAAfA,EAA0B,EAA1BA;AACAA,eAAe,iBAAfA,EAAkC,EAAlCA;qBAEexJ,a","names":["NODE","NODES","RENDERER","UNRENDERED","ROOT","OPTIONS","ROOT_NODES","WRAPPING_COMPONENT","LINKED_ROOTS","UPDATED_BY","findWhereUnwrapped","wrapper","predicate","filter","treeFilter","flatMap","n","getNodeInternal","filterWhereUnwrapped","wrap","getNodesInternal","Boolean","getRootNodeInternal","length","Error","nodeParents","node","privateSetNodes","nodes","Array","isArray","ReactWrapper","root","passedOptions","_classCallCheck","global","window","document","options","adapter","isValidElement","TypeError","renderer","createRenderer","mode","render","context","getNode","wrappingComponent","getWrappingComponentRenderer","WrappingComponentWrapper","push","single","_this","nodeToElement","map","_this2","nodeToHostNode","refname","instance","refs","_this3","update","forEach","linkedRoot","_this4","_this5","unmount","_this6","props","callback","undefined","arguments","_this7","state","nodeType","setState","_this8","invokeSetStateCallback","call","_this9","nodeOrNodes","other","nodeEqual","elementToNode","rstNode","a","b","every","_this10","containsMatchingElement","some","_this11","_this12","_this13","selector","_this14","html","event","mock","_this15","simulateEvent","error","thisNode","_this16","simulateError","rootNode","nodeHierarchy","concat","propsOfNode","name","_state","_this17","_this18","_context","allChildren","index","_this19","children","at","allParents","_this20","parents","get","is","matchingAncestors","first","findWhere","propName","handler","_this21","prop","args","response","wrapInvoke","RangeError","_this22","propValue","element","wrapped","key","displayNameOfNode","className","indexOf","console","warn","fn","i","_this23","_this24","initialValue","reduce","accum","_this25","reduceRight","_this26","begin","end","slice","_this27","_this28","_this29","flattened","_this30","getElements","exists","find","fnName","intercepter","attachTo","filterWhere","type","_this31","ITERATOR_SYMBOL","Object","defineProperty","prototype","configurable","value","iterator","iter","next","done","privateWarning","extraMessage","enumerable"],"sources":["../src/ReactWrapper.js"],"sourcesContent":["import flat from 'array.prototype.flat';\nimport has from 'has';\n\nimport {\n  containsChildrenSubArray,\n  typeOfNode,\n  displayNameOfNode,\n  ITERATOR_SYMBOL,\n  nodeEqual,\n  nodeMatches,\n  makeOptions,\n  sym,\n  privateSet,\n  cloneElement,\n  renderedDive,\n  isCustomComponent,\n  loadCheerioRoot,\n} from './Utils';\nimport getAdapter from './getAdapter';\nimport { debugNodes } from './Debug';\nimport {\n  propsOfNode,\n  hasClassName,\n  childrenOfNode,\n  parentsOfNode,\n  treeFilter,\n  getTextFromHostNodes,\n  getHTMLFromHostNodes,\n} from './RSTTraversal';\n\nimport { buildPredicate, reduceTreesBySelector } from './selectors';\n\nconst NODE = sym('__node__');\nconst NODES = sym('__nodes__');\nconst RENDERER = sym('__renderer__');\nconst UNRENDERED = sym('__unrendered__');\nconst ROOT = sym('__root__');\nconst OPTIONS = sym('__options__');\nconst ROOT_NODES = sym('__rootNodes__');\nconst WRAPPING_COMPONENT = sym('__wrappingComponent__');\nconst LINKED_ROOTS = sym('__linkedRoots__');\nconst UPDATED_BY = sym('__updatedBy__');\n\n/**\n * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n * function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @param {Function} filter\n * @returns {ReactWrapper}\n */\nfunction findWhereUnwrapped(wrapper, predicate, filter = treeFilter) {\n  return wrapper.flatMap((n) => filter(n.getNodeInternal(), predicate));\n}\n\n/**\n * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n * the provided predicate function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @returns {ReactWrapper}\n */\nfunction filterWhereUnwrapped(wrapper, predicate) {\n  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));\n}\n\nfunction getRootNodeInternal(wrapper) {\n  if (wrapper[ROOT].length !== 1) {\n    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');\n  }\n  if (wrapper[ROOT] !== wrapper) {\n    return wrapper[ROOT_NODES][0];\n  }\n  return wrapper[ROOT][NODE];\n}\n\nfunction nodeParents(wrapper, node) {\n  return parentsOfNode(node, getRootNodeInternal(wrapper));\n}\n\nfunction privateSetNodes(wrapper, nodes) {\n  if (!nodes) {\n    privateSet(wrapper, NODE, null);\n    privateSet(wrapper, NODES, []);\n  } else if (!Array.isArray(nodes)) {\n    privateSet(wrapper, NODE, nodes);\n    privateSet(wrapper, NODES, [nodes]);\n  } else {\n    privateSet(wrapper, NODE, nodes[0]);\n    privateSet(wrapper, NODES, nodes);\n  }\n  privateSet(wrapper, 'length', wrapper[NODES].length);\n}\n\n/**\n * @class ReactWrapper\n */\nclass ReactWrapper {\n  constructor(nodes, root, passedOptions = {}) {\n    if (!global.window && !global.document) {\n      throw new Error('It looks like you called `mount()` without a global document being loaded.');\n    }\n    const options = makeOptions(passedOptions);\n\n    if (!root) {\n      const adapter = getAdapter(options);\n      if (!adapter.isValidElement(nodes)) {\n        throw new TypeError('ReactWrapper can only wrap valid elements');\n      }\n\n      const renderer = adapter.createRenderer({ mode: 'mount', ...options });\n      privateSet(this, RENDERER, renderer);\n      renderer.render(nodes, options.context);\n      privateSet(this, ROOT, this);\n      privateSetNodes(this, this[RENDERER].getNode());\n      privateSet(this, OPTIONS, options);\n      privateSet(this, LINKED_ROOTS, []);\n\n      if (isCustomComponent(options.wrappingComponent, adapter)) {\n        if (typeof this[RENDERER].getWrappingComponentRenderer !== 'function') {\n          throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n        }\n\n        // eslint-disable-next-line no-use-before-define\n        privateSet(this, WRAPPING_COMPONENT, new WrappingComponentWrapper(\n          this, this[RENDERER].getWrappingComponentRenderer(),\n        ));\n        this[LINKED_ROOTS].push(this[WRAPPING_COMPONENT]);\n      }\n    } else {\n      privateSet(this, RENDERER, root[RENDERER]);\n      privateSet(this, ROOT, root);\n      privateSetNodes(this, nodes);\n      privateSet(this, ROOT_NODES, root[NODES]);\n      privateSet(this, OPTIONS, root[OPTIONS]);\n      privateSet(this, LINKED_ROOTS, []);\n    }\n    privateSet(this, UNRENDERED, nodes);\n    privateSet(this, UPDATED_BY, null);\n  }\n\n  /**\n   * Returns the root wrapper\n   *\n   * @return {ReactWrapper}\n   */\n  root() {\n    return this[ROOT];\n  }\n\n  /**\n   * Returns the wrapped component.\n   *\n   * @return {ReactComponent}\n   */\n  getNodeInternal() {\n    if (this.length !== 1) {\n      throw new Error('ReactWrapper::getNode() can only be called when wrapping one node');\n    }\n    return this[NODES][0];\n  }\n\n  /**\n   * Returns the the wrapped components.\n   *\n   * @return {Array<ReactComponent>}\n   */\n  getNodesInternal() {\n    return this[NODES];\n  }\n\n  /**\n   * Returns the wrapped ReactElement.\n   *\n   * @return {ReactElement}\n   */\n  getElement() {\n    return this.single('getElement', () => getAdapter(this[OPTIONS]).nodeToElement(this[NODE]));\n  }\n\n  /**\n   * Returns the wrapped ReactElements.\n   *\n   * @return {Array<ReactElement>}\n   */\n  getElements() {\n    return this[NODES].map((n) => getAdapter(this[OPTIONS]).nodeToElement(n));\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNode() {\n    throw new Error('ReactWrapper::getNode() is no longer supported. Use ReactWrapper::instance() instead');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNodes() {\n    throw new Error('ReactWrapper::getNodes() is no longer supported.');\n  }\n\n  /**\n   * Returns the outer most DOMComponent of the current wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {DOMComponent}\n   */\n  getDOMNode() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('getDOMNode', (n) => adapter.nodeToHostNode(n, true));\n  }\n\n  /**\n   * If the root component contained a ref, you can access it here and get the relevant\n   * react component instance or HTML element instance.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {String} refname\n   * @returns {ReactComponent | HTMLElement}\n   */\n  ref(refname) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::ref(refname) can only be called on the root');\n    }\n    return this.instance().refs[refname];\n  }\n\n  /**\n   * Returns the wrapper's underlying instance.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * const inst = wrapper.instance();\n   * expect(inst).to.be.instanceOf(MyComponent);\n   * ```\n   * @returns {ReactComponent|DOMComponent}\n   */\n  instance() {\n    return this.single('instance', () => this[NODE].instance);\n  }\n\n  /**\n   * If a `wrappingComponent` was passed in `options`, this methods returns a `ReactWrapper` around\n   * the rendered `wrappingComponent`. This `ReactWrapper` can be used to update the\n   * `wrappingComponent`'s props, state, etc.\n   *\n   * @returns ReactWrapper\n   */\n  getWrappingComponent() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::getWrappingComponent() can only be called on the root');\n    }\n    if (!this[OPTIONS].wrappingComponent) {\n      throw new Error('ReactWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');\n    }\n    return this[WRAPPING_COMPONENT];\n  }\n\n  /**\n   * Forces a re-render. Useful to run before checking the render output if something external\n   * may be updating the state of the component somewhere.\n   *\n   * NOTE: no matter what instance this is called on, it will always update the root.\n   *\n   * @returns {ReactWrapper}\n   */\n  update() {\n    const root = this[ROOT];\n    if (this !== root) {\n      return root.update();\n    }\n    privateSetNodes(this, this[RENDERER].getNode());\n    this[LINKED_ROOTS].forEach((linkedRoot) => {\n      if (linkedRoot !== this[UPDATED_BY]) {\n        /* eslint-disable no-param-reassign */\n        // Only update a linked it root if it is not the originator of our update().\n        // This is needed to prevent infinite recursion when there is a bi-directional\n        // link between two roots.\n        linkedRoot[UPDATED_BY] = this;\n        try {\n          linkedRoot.update();\n        } finally {\n          linkedRoot[UPDATED_BY] = null;\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method that unmounts the component. This can be used to simulate a component going through\n   * and unmount/mount lifecycle.\n   *\n   * @returns {ReactWrapper}\n   */\n  unmount() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::unmount() can only be called on the root');\n    }\n    this.single('unmount', () => {\n      this[RENDERER].unmount();\n      this.update();\n    });\n    return this;\n  }\n\n  /**\n   * A method that re-mounts the component, if it is not currently mounted.\n   * This can be used to simulate a component going through\n   * an unmount/mount lifecycle.\n   *\n   * @returns {ReactWrapper}\n   */\n  mount() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::mount() can only be called on the root');\n    }\n    this[RENDERER].render(this[UNRENDERED], this[OPTIONS].context, () => this.update());\n    return this;\n  }\n\n  /**\n   * A method that sets the props of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing props. Calling this, for\n   * instance, will call the `componentWillReceiveProps` lifecycle method.\n   *\n   * Similar to `setState`, this method accepts a props object and will merge it in with the already\n   * existing props.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} props object\n   * @param {Function} cb - callback function\n   * @returns {ReactWrapper}\n   */\n  setProps(props, callback = undefined) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::setProps() can only be called on the root');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');\n    }\n    const adapter = getAdapter(this[OPTIONS]);\n    this[UNRENDERED] = cloneElement(adapter, this[UNRENDERED], props);\n    this[RENDERER].render(this[UNRENDERED], null, () => {\n      this.update();\n      if (callback) {\n        callback();\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method to invoke `setState` on the root component instance similar to how you might in the\n   * definition of the component, and re-renders.  This method is useful for testing your component\n   * in hard to achieve states, however should be used sparingly. If possible, you should utilize\n   * your component's external API in order to get it into whatever state you want to test, in order\n   * to be as accurate of a test as possible. This is not always practical, however.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} state to merge\n   * @param {Function} cb - callback function\n   * @returns {ReactWrapper}\n   */\n  setState(state, callback = undefined) {\n    if (this.instance() === null || this.getNodeInternal().nodeType !== 'class') {\n      throw new Error('ReactWrapper::setState() can only be called on class components');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setState() expects a function as its second argument');\n    }\n    this.instance().setState(state, () => {\n      this.update();\n      if (callback) {\n        const adapter = getAdapter(this[OPTIONS]);\n        const instance = this.instance();\n        if (adapter.invokeSetStateCallback) {\n          adapter.invokeSetStateCallback(instance, callback);\n        } else {\n          callback.call(instance);\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method that sets the context of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing contexts.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} context object\n   * @returns {ReactWrapper}\n   */\n  setContext(context) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::setContext() can only be called on the root');\n    }\n    if (!this[OPTIONS].context) {\n      throw new Error('ReactWrapper::setContext() can only be called on a wrapper that was originally passed a context option');\n    }\n    this[RENDERER].render(this[UNRENDERED], context, () => this.update());\n    return this;\n  }\n\n  /**\n   * Whether or not a given react element exists in the mount render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement|Array<ReactElement>} nodeOrNodes\n   * @returns {Boolean}\n   */\n  contains(nodeOrNodes) {\n    const adapter = getAdapter(this[OPTIONS]);\n\n    const predicate = Array.isArray(nodeOrNodes)\n      ? (other) => containsChildrenSubArray(\n        nodeEqual,\n        other,\n        nodeOrNodes.map((node) => adapter.elementToNode(node)),\n      )\n      : (other) => nodeEqual(adapter.elementToNode(nodeOrNodes), other);\n\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not a given react element exists in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div><div class=\"foo\">Hello</div></div>\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  containsMatchingElement(node) {\n    const rstNode = getAdapter(this[OPTIONS]).elementToNode(node);\n    const predicate = (other) => nodeMatches(rstNode, other, (a, b) => a <= b);\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not all the given react elements exist in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsAllMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAllMatchingElements(nodes) {\n    if (!Array.isArray(nodes)) {\n      throw new TypeError('nodes should be an Array');\n    }\n\n    return nodes.every((node) => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not one of the given react elements exists in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsAnyMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAnyMatchingElements(nodes) {\n    return Array.isArray(nodes) && nodes.some((node) => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not a given react element exists in the render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  equals(node) {\n    return this.single('equals', () => nodeEqual(this.getNodeInternal(), node));\n  }\n\n  /**\n   * Whether or not a given react element matches the render tree.\n   * Match is based on the expected element and not on wrapper root node.\n   * It will determine if the wrapper root node \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrapper root node and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div class=\"foo\">Hello</div>\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  matchesElement(node) {\n    return this.single('matchesElement', () => {\n      const adapter = getAdapter(this[OPTIONS]);\n      const rstNode = adapter.elementToNode(node);\n      return nodeMatches(rstNode, this.getNodeInternal(), (a, b) => a <= b);\n    });\n  }\n\n  /**\n   * Finds every node in the render tree of the current wrapper that matches the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  find(selector) {\n    return this.wrap(reduceTreesBySelector(selector, this.getNodesInternal()));\n  }\n\n  /**\n   * Returns whether or not current node matches a provided selector.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {boolean}\n   */\n  is(selector) {\n    const predicate = buildPredicate(selector);\n    return this.single('is', (n) => predicate(n));\n  }\n\n  /**\n   * Returns true if the component rendered nothing, i.e., null or false.\n   *\n   * @returns {boolean}\n   */\n  isEmptyRender() {\n    const nodes = this.getNodeInternal();\n\n    return renderedDive(nodes);\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {ReactWrapper}\n   */\n  filterWhere(predicate) {\n    return filterWhereUnwrapped(this, (n) => predicate(this.wrap(n)));\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  filter(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, predicate);\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper that did not match\n   * the provided selector. Essentially the inverse of `filter`.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  not(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, (n) => !predicate(n));\n  }\n\n  /**\n   * Returns a string of the rendered text of the current render tree.  This function should be\n   * looked at with skepticism if being used to test what the actual HTML output of the component\n   * will be. If that is what you would like to test, use enzyme's `render` function instead.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  text() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('text', (n) => getTextFromHostNodes(n, adapter));\n  }\n\n  /**\n   * Returns the HTML of the node.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  html() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('html', (n) => getHTMLFromHostNodes(n, adapter));\n  }\n\n  /**\n   * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {CheerioWrapper}\n   */\n  render() {\n    const html = this.html();\n    return loadCheerioRoot(html);\n  }\n\n  /**\n   * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of\n   * testing events should be met with some skepticism.\n   *\n   * @param {String} event\n   * @param {Object} mock (optional)\n   * @returns {ReactWrapper}\n   */\n  simulate(event, mock = {}) {\n    return this.single('simulate', (n) => {\n      this[RENDERER].simulateEvent(n, event, mock);\n      this[ROOT].update();\n      return this;\n    });\n  }\n\n  /**\n   * Used to simulate throwing a rendering error. Pass an error to throw.\n   *\n   * @param {String} error\n   * @returns {ReactWrapper}\n   */\n  simulateError(error) {\n    if (this[ROOT] === this) {\n      throw new Error('ReactWrapper::simulateError() may not be called on the root');\n    }\n\n    return this.single('simulateError', (thisNode) => {\n      if (thisNode.nodeType === 'host') {\n        throw new Error('ReactWrapper::simulateError() can only be called on custom components');\n      }\n\n      const renderer = this[RENDERER];\n      if (typeof renderer.simulateError !== 'function') {\n        throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');\n      }\n\n      const rootNode = getRootNodeInternal(this);\n      const nodeHierarchy = [thisNode].concat(nodeParents(this, thisNode));\n      renderer.simulateError(nodeHierarchy, rootNode, error);\n\n      this[ROOT].update();\n      return this;\n    });\n  }\n\n  /**\n   * Returns the props hash for the root node of the wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {Object}\n   */\n  props() {\n    return this.single('props', propsOfNode);\n  }\n\n  /**\n   * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it\n   * will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  state(name) {\n    const thisNode = this[ROOT] === this ? this[RENDERER].getNode() : this.getNodeInternal();\n    if (this.instance() === null || thisNode.nodeType !== 'class') {\n      throw new Error('ReactWrapper::state() can only be called on class components');\n    }\n    const _state = this.single('state', () => this.instance().state);\n    if (typeof name !== 'undefined') {\n      if (_state == null) {\n        throw new TypeError(`ReactWrapper::state(\"${name}\") requires that \\`state\\` not be \\`null\\` or \\`undefined\\``);\n      }\n      return _state[name];\n    }\n    return _state;\n  }\n\n  /**\n   * Returns the context hash for the root node of the wrapper.\n   * Optionally pass in a prop name and it will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  context(name) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::context() can only be called on the root');\n    }\n    const instance = this.single('context', () => this.instance());\n    if (instance === null) {\n      throw new Error('ReactWrapper::context() can only be called on components with instances');\n    }\n    const _context = instance.context;\n    if (typeof name !== 'undefined') {\n      return _context[name];\n    }\n    return _context;\n  }\n\n  /**\n   * Returns a new wrapper with all of the children of the current wrapper.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ReactWrapper}\n   */\n  children(selector) {\n    const allChildren = this.flatMap((n) => childrenOfNode(n.getNodeInternal()));\n    return selector ? allChildren.filter(selector) : allChildren;\n  }\n\n  /**\n   * Returns a new wrapper with a specific child\n   *\n   * @param {Number} [index]\n   * @returns {ReactWrapper}\n   */\n  childAt(index) {\n    return this.single('childAt', () => this.children().at(index));\n  }\n\n  /**\n   * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node\n   * in the current wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ReactWrapper}\n   */\n  parents(selector) {\n    return this.single('parents', (n) => {\n      const allParents = this.wrap(nodeParents(this, n));\n      return selector ? allParents.filter(selector) : allParents;\n    });\n  }\n\n  /**\n   * Returns a wrapper around the immediate parent of the current node.\n   *\n   * @returns {ReactWrapper}\n   */\n  parent() {\n    return this.flatMap((n) => [n.parents().get(0)]);\n  }\n\n  /**\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  closest(selector) {\n    if (this.is(selector)) {\n      return this;\n    }\n    const matchingAncestors = this.parents().filter(selector);\n    return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(() => false);\n  }\n\n  /**\n   * Returns the value of  prop with the given name of the root node.\n   *\n   * @param {String} propName\n   * @returns {*}\n   */\n  prop(propName) {\n    return this.props()[propName];\n  }\n\n  /**\n   * Used to invoke a function prop.\n   * Will invoke an function prop and return its value.\n   *\n   * @param {String} propName\n   * @returns {Any}\n   */\n  invoke(propName) {\n    return this.single('invoke', () => {\n      const handler = this.prop(propName);\n      if (typeof handler !== 'function') {\n        throw new TypeError('ReactWrapper::invoke() requires the name of a prop whose value is a function');\n      }\n      return (...args) => {\n        const response = typeof this[RENDERER].wrapInvoke === 'function'\n          ? this[RENDERER].wrapInvoke(() => handler(...args))\n          : handler(...args);\n        this[ROOT].update();\n        return response;\n      };\n    });\n  }\n\n  /**\n   * Returns a wrapper of the node rendered by the provided render prop.\n   *\n   * @param {String} propName\n   * @returns {Function}\n   */\n  renderProp(propName) {\n    const adapter = getAdapter(this[OPTIONS]);\n    if (typeof adapter.wrap !== 'function') {\n      throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');\n    }\n\n    return this.single('renderProp', (n) => {\n      if (n.nodeType === 'host') {\n        throw new TypeError('ReactWrapper::renderProp() can only be called on custom components');\n      }\n      if (typeof propName !== 'string') {\n        throw new TypeError('ReactWrapper::renderProp(): `propName` must be a string');\n      }\n      const props = this.props();\n      if (!has(props, propName)) {\n        throw new Error(`ReactWrapper::renderProp(): no prop called ${propName} found`);\n      }\n      const propValue = props[propName];\n      if (typeof propValue !== 'function') {\n        throw new TypeError(`ReactWrapper::renderProp(): expected prop ${propName} to contain a function, but it holds ${typeof propValue}`);\n      }\n\n      return (...args) => {\n        const element = propValue(...args);\n        const wrapped = adapter.wrap(element);\n        return this.wrap(wrapped, null, this[OPTIONS]);\n      };\n    });\n  }\n\n  /**\n   * Returns the key assigned to the current node.\n   *\n   * @returns {String}\n   */\n  key() {\n    return this.single('key', (n) => (n.key === undefined ? null : n.key));\n  }\n\n  /**\n   * Returns the type of the root node of this wrapper. If it's a composite component, this will be\n   * the component constructor. If it's native DOM node, it will be a string.\n   *\n   * @returns {String|Function}\n   */\n  type() {\n    return this.single('type', (n) => typeOfNode(n));\n  }\n\n  /**\n   * Returns the name of the root node of this wrapper.\n   *\n   * In order of precedence => type.displayName -> type.name -> type.\n   *\n   * @returns {String}\n   */\n  name() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('name', (n) => (\n      adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : displayNameOfNode(n)\n    ));\n  }\n\n  /**\n   * Returns whether or not the current root node has the given class name or not.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} className\n   * @returns {Boolean}\n   */\n  hasClass(className) {\n    if (typeof className === 'string' && className.indexOf('.') !== -1) {\n      // eslint-disable-next-line no-console\n      console.warn('It looks like you\\'re calling `ReactWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');\n    }\n    return this.single('hasClass', (n) => hasClassName(n, className));\n  }\n\n  /**\n   * Iterates through each node of the current wrapper and executes the provided function with a\n   * wrapper around the corresponding node passed in as the first argument.\n   *\n   * @param {Function} fn\n   * @returns {ReactWrapper}\n   */\n  forEach(fn) {\n    this.getNodesInternal().forEach((n, i) => fn.call(this, this.wrap(n), i));\n    return this;\n  }\n\n  /**\n   * Maps the current array of nodes to another array. Each node is passed in as a `ReactWrapper`\n   * to the map function.\n   *\n   * @param {Function} fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Reduces the current array of nodes to another array.\n   * Each node is passed in as a `ShallowWrapper` to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduce(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduce(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduce((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Reduces the current array of nodes to another array, from right to left. Each node is passed\n   * in as a `ShallowWrapper` to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduceRight(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduceRight(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduceRight((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the\n   * rules of `Array#slice`.\n   *\n   * @param {Number} begin\n   * @param {Number} end\n   * @returns {ShallowWrapper}\n   */\n  slice(begin, end) {\n    return this.wrap(this.getNodesInternal().slice(begin, end));\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  some(selector) {\n    if (this[ROOT] === this) {\n      throw new Error('ReactWrapper::some() can not be called on the root');\n    }\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().some(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  someWhere(predicate) {\n    return this.getNodesInternal().some((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Returns whether or not all of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  every(selector) {\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().every(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  everyWhere(predicate) {\n    return this.getNodesInternal().every((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Utility method used to create new wrappers with a mapping function that returns an array of\n   * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around\n   * all of the mapped nodes flattened (and de-duplicated).\n   *\n   * @param {Function} fn\n   * @returns {ReactWrapper}\n   */\n  flatMap(fn) {\n    const nodes = this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n    const flattened = flat(nodes, 1);\n    return this.wrap(flattened.filter(Boolean));\n  }\n\n  /**\n   * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n   * function.\n   *\n   * @param {Function} predicate\n   * @returns {ReactWrapper}\n   */\n  findWhere(predicate) {\n    return findWhereUnwrapped(this, (n) => {\n      const node = this.wrap(n);\n      return node.length > 0 && predicate(node);\n    });\n  }\n\n  /**\n   * Returns the node at a given index of the current wrapper.\n   *\n   * @param {Number} index\n   * @returns {ReactElement}\n   */\n  get(index) {\n    return this.getElements()[index];\n  }\n\n  /**\n   * Returns a wrapper around the node at a given index of the current wrapper.\n   *\n   * @param {Number} index\n   * @returns {ReactWrapper}\n   */\n  at(index) {\n    const nodes = this.getNodesInternal();\n    if (index < nodes.length) {\n      return this.wrap(nodes[index]);\n    }\n    return this.wrap([]);\n  }\n\n  /**\n   * Returns a wrapper around the first node of the current wrapper.\n   *\n   * @returns {ReactWrapper}\n   */\n  first() {\n    return this.at(0);\n  }\n\n  /**\n   * Returns a wrapper around the last node of the current wrapper.\n   *\n   * @returns {ReactWrapper}\n   */\n  last() {\n    return this.at(this.length - 1);\n  }\n\n  /**\n   * Delegates to exists()\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    // eslint-disable-next-line no-console\n    console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');\n    return !this.exists();\n  }\n\n  /**\n   * Returns true if the current wrapper has nodes. False otherwise.\n   * If called with a selector it returns `.find(selector).exists()` instead.\n   *\n   * @param {EnzymeSelector} selector (optional)\n   * @returns {boolean}\n   */\n  exists(selector = null) {\n    return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;\n  }\n\n  /**\n   * Utility method that throws an error if the current instance has a length other than one.\n   * This is primarily used to enforce that certain methods are only run on a wrapper when it is\n   * wrapping a single node.\n   *\n   * @param {Function} fn\n   * @returns {*}\n   */\n  single(name, fn) {\n    const fnName = typeof name === 'string' ? name : 'unknown';\n    const callback = typeof fn === 'function' ? fn : name;\n    if (this.length !== 1) {\n      throw new Error(`Method ${fnName} is meant to be run on 1 node. ${this.length} found instead.`);\n    }\n    return callback.call(this, this.getNodeInternal());\n  }\n\n  /**\n   * Helpful utility method to create a new wrapper with the same root as the current wrapper, with\n   * any nodes passed in as the first parameter automatically wrapped.\n   *\n   * @param {ReactWrapper|ReactElement|Array<ReactElement>} node\n   * @returns {ReactWrapper}\n   */\n  wrap(node, root = this[ROOT], ...args) {\n    if (node instanceof ReactWrapper) {\n      return node;\n    }\n    return new ReactWrapper(node, root, ...args);\n  }\n\n  /**\n   * Returns an HTML-like string of the shallow render for debugging purposes.\n   *\n   * @param {Object} [options] - Property bag of additional options.\n   * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.\n   * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.\n   * @returns {String}\n   */\n  debug(options = {}) {\n    return debugNodes(this.getNodesInternal(), options);\n  }\n\n  /**\n   * Invokes intercepter and returns itself. intercepter is called with itself.\n   * This is helpful when debugging nodes in method chains.\n   * @param fn\n   * @returns {ReactWrapper}\n   */\n  tap(intercepter) {\n    intercepter(this);\n    return this;\n  }\n\n  /**\n   * Detaches the react tree from the DOM. Runs `ReactDOM.unmountComponentAtNode()` under the hood.\n   *\n   * This method will most commonly be used as a \"cleanup\" method if you decide to use the\n   * `attachTo` option in `mount(node, options)`.\n   *\n   * The method is intentionally not \"fluent\" (in that it doesn't return `this`) because you should\n   * not be doing anything with this wrapper after this method is called.\n   */\n  detach() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::detach() can only be called on the root');\n    }\n    if (!this[OPTIONS].attachTo) {\n      throw new Error('ReactWrapper::detach() can only be called on when the `attachTo` option was passed into `mount()`.');\n    }\n    this[RENDERER].unmount();\n  }\n\n  /**\n   * Strips out all the not host-nodes from the list of nodes\n   *\n   * This method is useful if you want to check for the presence of host nodes\n   * (actually rendered HTML elements) ignoring the React nodes.\n   */\n  hostNodes() {\n    return this.filterWhere((n) => typeof n.type() === 'string');\n  }\n}\n\n/**\n * A *special* \"root\" wrapper that represents the component passed as `wrappingComponent`.\n * It is linked to the primary root such that updates to it will update the primary,\n * and vice versa.\n *\n * @class WrappingComponentWrapper\n */\nclass WrappingComponentWrapper extends ReactWrapper {\n  /* eslint-disable class-methods-use-this */\n  constructor(root, renderer) {\n    super(renderer.getNode(), root);\n\n    privateSet(this, ROOT, this);\n    privateSet(this, RENDERER, renderer);\n    this[LINKED_ROOTS].push(root);\n  }\n\n  getWrappingComponent() {\n    throw new TypeError('ReactWrapper::getWrappingComponent() can only be called on the root');\n  }\n}\n\nif (ITERATOR_SYMBOL) {\n  Object.defineProperty(ReactWrapper.prototype, ITERATOR_SYMBOL, {\n    configurable: true,\n    value: function iterator() {\n      const iter = this[NODES][ITERATOR_SYMBOL]();\n      const adapter = getAdapter(this[OPTIONS]);\n      return {\n        [ITERATOR_SYMBOL]() { return this; },\n        next() {\n          const next = iter.next();\n          if (next.done) {\n            return { done: true };\n          }\n          return {\n            done: false,\n            value: adapter.nodeToElement(next.value),\n          };\n        },\n      };\n    },\n  });\n}\n\nfunction privateWarning(prop, extraMessage) {\n  Object.defineProperty(ReactWrapper.prototype, prop, {\n    get() {\n      throw new Error(`\n        Attempted to access ReactWrapper::${prop}, which was previously a private property on\n        Enzyme ReactWrapper instances, but is no longer and should not be relied upon.\n        ${extraMessage}\n      `);\n    },\n    enumerable: false,\n    configurable: false,\n  });\n}\n\nprivateWarning('node', 'Consider using the getElement() method instead.');\nprivateWarning('nodes', 'Consider using the getElements() method instead.');\nprivateWarning('renderer', '');\nprivateWarning('options', '');\nprivateWarning('complexSelector', '');\n\nexport default ReactWrapper;\n"]}