79279c3e7d21fc7d749b2ba9fb100555
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

exports.buildPredicate = buildPredicate;
exports.reduceTreeBySelector = reduceTreeBySelector;
exports.reduceTreesBySelector = reduceTreesBySelector;

var _rstSelectorParser = require('rst-selector-parser');

var _object = require('object.values');

var _object2 = _interopRequireDefault(_object);

var _arrayPrototype = require('array.prototype.flat');

var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);

var _objectIs = require('object-is');

var _objectIs2 = _interopRequireDefault(_objectIs);

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _byConstructor = require('html-element-map/byConstructor');

var _byConstructor2 = _interopRequireDefault(_byConstructor);

var _RSTTraversal = require('./RSTTraversal');

var _Utils = require('./Utils');

var _getAdapter = require('./getAdapter');

var _getAdapter2 = _interopRequireDefault(_getAdapter);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return Array.from(arr);
  }
} // our CSS selector parser instance


var parser = (0, _rstSelectorParser.createParser)(); // Combinators that allow you to chance selectors

var CHILD = 'childCombinator';
var ADJACENT_SIBLING = 'adjacentSiblingCombinator';
var GENERAL_SIBLING = 'generalSiblingCombinator';
var DESCENDANT = 'descendantCombinator'; // Selectors for targeting elements

var SELECTOR = 'selector';
var TYPE_SELECTOR = 'typeSelector';
var CLASS_SELECTOR = 'classSelector';
var ID_SELECTOR = 'idSelector';
var UNIVERSAL_SELECTOR = 'universalSelector';
var ATTRIBUTE_PRESENCE = 'attributePresenceSelector';
var ATTRIBUTE_VALUE = 'attributeValueSelector'; // @TODO we dont support these, throw if they are used

var PSEUDO_CLASS = 'pseudoClassSelector';
var PSEUDO_ELEMENT = 'pseudoElementSelector';
var EXACT_ATTRIBUTE_OPERATOR = '=';
var WHITELIST_ATTRIBUTE_OPERATOR = '~=';
var HYPHENATED_ATTRIBUTE_OPERATOR = '|=';
var PREFIX_ATTRIBUTE_OPERATOR = '^=';
var SUFFIX_ATTRIBUTE_OPERATOR = '$=';
var SUBSTRING_ATTRIBUTE_OPERATOR = '*=';

function unique(arr) {
  return [].concat(_toConsumableArray(new Set(arr)));
}
/**
 * Calls reduce on a array of nodes with the passed
 * function, returning only unique results.
 * @param {Function} fn
 * @param {Array<Node>} nodes
 */


function uniqueReduce(fn, nodes) {
  return unique(nodes.reduce(fn, []));
}
/**
 * Takes a CSS selector and returns a set of tokens parsed
 * by scalpel.
 * @param {String} selector
 */


function safelyGenerateTokens(selector) {
  try {
    return parser.parse(selector);
  } catch (err) {
    throw new Error('Failed to parse selector: ' + String(selector));
  }
}

function matchAttributeSelector(node, token) {
  var operator = token.operator,
      value = token.value,
      name = token.name;
  var nodeProps = (0, _Utils.propsOfNode)(node);
  var descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);

  if (descriptor && descriptor.get) {
    return false;
  }

  var nodePropValue = nodeProps[name];

  if (typeof nodePropValue === 'undefined') {
    return false;
  }

  if (token.type === ATTRIBUTE_PRESENCE) {
    return (0, _has2['default'])(nodeProps, token.name);
  } // Only the exact value operator ("=") can match non-strings


  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {
    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {
      return false;
    }
  }

  switch (operator) {
    /**
     * Represents an element with the att attribute whose value is exactly "val".
     * @example
     * [attr="val"] matches attr="val"
     */
    case EXACT_ATTRIBUTE_OPERATOR:
      return (0, _objectIs2['default'])(nodePropValue, value);

    /**
     * Represents an element with the att attribute whose value is a whitespace-separated
     * list of words, one of which is exactly
     * @example
     *  [rel~="copyright"] matches rel="copyright other"
     */

    case WHITELIST_ATTRIBUTE_OPERATOR:
      return nodePropValue.split(' ').indexOf(value) !== -1;

    /**
     * Represents an element with the att attribute, its value either being exactly the
     * value or beginning with the value immediately followed by "-"
     * @example
     * [hreflang|="en"] matches hreflang="en-US"
     */

    case HYPHENATED_ATTRIBUTE_OPERATOR:
      return nodePropValue === value || nodePropValue.startsWith(String(value) + '-');

    /**
     * Represents an element with the att attribute whose value begins with the prefix value.
     * If the value is the empty string then the selector does not represent anything.
     * @example
     * [type^="image"] matches type="imageobject"
     */

    case PREFIX_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.slice(0, value.length) === value;

    /**
     * Represents an element with the att attribute whose value ends with the suffix value.
     * If the value is the empty string then the selector does not represent anything.
     * @example
     * [type$="image"] matches type="imageobject"
     */

    case SUFFIX_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.slice(-value.length) === value;

    /**
     * Represents an element with the att attribute whose value contains at least one
     * instance of the value. If value is the empty string then the
     * selector does not represent anything.
     * @example
     * [title*="hello"] matches title="well hello there"
     */

    case SUBSTRING_ATTRIBUTE_OPERATOR:
      return value === '' ? false : nodePropValue.indexOf(value) !== -1;

    default:
      throw new Error('Enzyme::Selector: Unknown attribute selector operator "' + String(operator) + '"');
  }
}

function matchPseudoSelector(node, token, root) {
  var name = token.name,
      parameters = token.parameters;

  if (name === 'not') {
    // eslint-disable-next-line no-use-before-define
    return parameters.every(function (selector) {
      return reduceTreeBySelector(selector, node).length === 0;
    });
  }

  if (name === 'empty') {
    return (0, _RSTTraversal.treeFilter)(node, function (n) {
      return n !== node;
    }).length === 0;
  }

  if (name === 'first-child') {
    var _findParentNode = (0, _RSTTraversal.findParentNode)(root, node),
        rendered = _findParentNode.rendered;

    var _rendered = _slicedToArray(rendered, 1),
        firstChild = _rendered[0];

    return firstChild === node;
  }

  if (name === 'last-child') {
    var _findParentNode2 = (0, _RSTTraversal.findParentNode)(root, node),
        _rendered2 = _findParentNode2.rendered;

    return _rendered2[_rendered2.length - 1] === node;
  }

  if (name === 'focus') {
    if (typeof document === 'undefined') {
      throw new Error('Enzyme::Selector does not support the ":focus" pseudo-element without a global `document`.');
    }

    var adapter = (0, _getAdapter2['default'])();
    /* eslint-env browser */

    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;
  }

  throw new TypeError('Enzyme::Selector does not support the "' + String(token.name) + '" pseudo-element or pseudo-class selectors.');
}
/**
 * Takes a node and a token and determines if the node
 * matches the predicate defined by the token.
 * @param {Node} node
 * @param {Token} token
 */


function nodeMatchesToken(node, token, root) {
  if (node === null || typeof node === 'string') {
    return false;
  }

  switch (token.type) {
    /**
     * Match every node
     * @example '*' matches every node
     */
    case UNIVERSAL_SELECTOR:
      return true;

    /**
     * Match against the className prop
     * @example '.active' matches <div className='active' />
     */

    case CLASS_SELECTOR:
      return (0, _RSTTraversal.hasClassName)(node, token.name);

    /**
     * Simple type matching
     * @example 'div' matches <div />
     */

    case TYPE_SELECTOR:
      return (0, _Utils.nodeHasType)(node, token.name);

    /**
     * Match against the `id` prop
     * @example '#nav' matches <ul id="nav" />
     */

    case ID_SELECTOR:
      return (0, _RSTTraversal.nodeHasId)(node, token.name);

    /**
     * Matches if an attribute is present, regardless
     * of its value
     * @example '[disabled]' matches <a disabled />
     */

    case ATTRIBUTE_PRESENCE:
      return matchAttributeSelector(node, token);

    /**
     * Matches if an attribute is present with the
     * provided value
     * @example '[data-foo=foo]' matches <div data-foo="foo" />
     */

    case ATTRIBUTE_VALUE:
      return matchAttributeSelector(node, token);

    case PSEUDO_ELEMENT:
    case PSEUDO_CLASS:
      return matchPseudoSelector(node, token, root);

    default:
      throw new Error('Unknown token type: ' + String(token.type));
  }
}
/**
 * Returns a predicate function that checks if a
 * node matches every token in the body of a selector
 * token.
 * @param {Token} token
 */


function buildPredicateFromToken(token, root) {
  return function (node) {
    return token.body.every(function (bodyToken) {
      return nodeMatchesToken(node, bodyToken, root);
    });
  };
}
/**
 * Returns whether a parsed selector is a complex selector, which
 * is defined as a selector that contains combinators.
 * @param {Array<Token>} tokens
 */


function isComplexSelector(tokens) {
  return tokens.some(function (token) {
    return token.type !== SELECTOR;
  });
}
/**
 * Takes a component constructor, object, or string representing
 * a simple selector and returns a predicate function that can
 * be applied to a single node.
 * @param {EnzymeSelector} selector
 */


function buildPredicate(selector) {
  // If the selector is a string, parse it as a simple CSS selector
  if (typeof selector === 'string') {
    var tokens = safelyGenerateTokens(selector);

    if (isComplexSelector(tokens)) {
      throw new TypeError('This method does not support complex CSS selectors');
    } // Simple selectors only have a single selector token


    return buildPredicateFromToken(tokens[0]);
  } // If the selector is an element type, check if the node's type matches


  var adapter = (0, _getAdapter2['default'])();
  var isElementType = adapter.isValidElementType ? adapter.isValidElementType(selector) : typeof selector === 'function';

  if (isElementType) {
    return function (node) {
      return adapter.matchesElementType(node, selector);
    };
  } // If the selector is an non-empty object, treat the keys/values as props


  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {
    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {
      var hasUndefinedValues = (0, _object2['default'])(selector).some(function (value) {
        return typeof value === 'undefined';
      });

      if (hasUndefinedValues) {
        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');
      }

      return function (node) {
        return (0, _RSTTraversal.nodeMatchesObjectProps)(node, selector);
      };
    }

    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');
  }

  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');
}
/**
 * Matches only nodes which are adjacent siblings (direct next sibling)
 * against a predicate, returning those that match.
 * @param {Array<Node>} nodes
 * @param {Function} predicate
 * @param {Node} root
 */


function matchAdjacentSiblings(nodes, predicate, root) {
  return nodes.reduce(function (matches, node) {
    var parent = (0, _RSTTraversal.findParentNode)(root, node); // If there's no parent, there's no siblings

    if (!parent) {
      return matches;
    }

    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);
    var nodeIndex = parentChildren.indexOf(node);
    var adjacentSibling = parentChildren[nodeIndex + 1]; // No sibling

    if (!adjacentSibling) {
      return matches;
    }

    if (predicate(adjacentSibling)) {
      matches.push(adjacentSibling);
    }

    return matches;
  }, []);
}
/**
 * Matches only nodes which are general siblings (any sibling *after*)
 * against a predicate, returning those that match.
 * @param {Array<Node>} nodes
 * @param {Function} predicate
 * @param {Node} root
 */


function matchGeneralSibling(nodes, predicate, root) {
  return uniqueReduce(function (matches, node) {
    var parent = (0, _RSTTraversal.findParentNode)(root, node);

    if (!parent) {
      return matches;
    }

    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);
    var nodeIndex = parentChildren.indexOf(node);
    var youngerSiblings = parentChildren.slice(nodeIndex + 1);
    return matches.concat(youngerSiblings.filter(predicate));
  }, nodes);
}
/**
 * Matches only nodes which are direct children (not grandchildren, etc.)
 * against a predicate, returning those that match.
 * @param {Array<Node>} nodes
 * @param {Function} predicate
 */


function matchDirectChild(nodes, predicate) {
  return uniqueReduce(function (matches, node) {
    return matches.concat((0, _RSTTraversal.childrenOfNode)(node).filter(predicate));
  }, nodes);
}
/**
 * Matches all descendant nodes against a predicate,
 * returning those that match.
 * @param {Array<Node>} nodes
 * @param {Function} predicate
 */


function matchDescendant(nodes, predicate) {
  return uniqueReduce(function (matches, node) {
    return matches.concat((0, _RSTTraversal.treeFilter)(node, predicate));
  }, (0, _arrayPrototype2['default'])(nodes.map(_RSTTraversal.childrenOfNode)));
}
/**
 * Takes an RST and reduces it to a set of nodes matching
 * the selector. The selector can be a simple selector, which
 * is handled by `buildPredicate`, or a complex CSS selector which
 * reduceTreeBySelector parses and reduces the tree based on the combinators.
 *
 * @param {EnzymeSelector} selector
 * @param {RSTNode} root
 */


function reduceTreeBySelector(selector, root) {
  if (typeof selector !== 'string') {
    var elements = (0, _byConstructor2['default'])(selector);

    if (elements.length > 0) {
      return (0, _arrayPrototype2['default'])(elements.map(function (x) {
        return reduceTreeBySelector(x.tag, root);
      })); // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved
      // const htmlTagNames = elements.map(x => x.tag).join(', ');
      // return reduceTreeBySelector(htmlTagNames, root);
    }
  }

  if (typeof selector === 'function' || (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {
    return (0, _RSTTraversal.treeFilter)(root, buildPredicate(selector));
  }

  var results = [];

  if (typeof selector === 'string') {
    var tokens = safelyGenerateTokens(selector);
    var index = 0;

    while (index < tokens.length) {
      var token = tokens[index];
      /**
       * There are two types of tokens in a CSS selector:
       *
       * 1. Selector tokens. These target nodes directly, like
       *    type or attribute selectors. These are easy to apply
       *    because we can traverse the tree and return only
       *    the nodes that match the predicate.
       *
       * 2. Combinator tokens. These tokens chain together
       *    selector nodes. For example > for children, or +
       *    for adjacent siblings. These are harder to match
       *    as we have to track where in the tree we are
       *    to determine if a selector node applies or not.
       */

      if (token.type === SELECTOR) {
        var predicate = buildPredicateFromToken(token, root);
        results = results.concat((0, _RSTTraversal.treeFilter)(root, predicate));
      } else {
        // We can assume there always all previously matched tokens since selectors
        // cannot start with combinators.
        var type = token.type; // We assume the next token is a selector, so move the index
        // forward and build the predicate.

        index += 1;

        var _predicate = buildPredicateFromToken(tokens[index], root); // We match against only the nodes which have already been matched,
        // since a combinator is meant to refine a previous selector.


        switch (type) {
          // The + combinator
          case ADJACENT_SIBLING:
            results = matchAdjacentSiblings(results, _predicate, root);
            break;
          // The ~ combinator

          case GENERAL_SIBLING:
            results = matchGeneralSibling(results, _predicate, root);
            break;
          // The > combinator

          case CHILD:
            results = matchDirectChild(results, _predicate);
            break;
          // The ' ' (whitespace) combinator

          case DESCENDANT:
            {
              results = matchDescendant(results, _predicate);
              break;
            }

          default:
            throw new Error('Unknown combinator selector: ' + String(type));
        }
      }

      index += 1;
    }
  } else {
    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');
  }

  return results;
}

function reduceTreesBySelector(selector, roots) {
  var results = roots.map(function (n) {
    return reduceTreeBySelector(selector, n);
  });
  return unique((0, _arrayPrototype2['default'])(results, 1));
} //# sourceMappingURL=selectors.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFkLENBQVAzRSxDQUFQO0FBQ0QsQyIsIm5hbWVzIjpbImJ1aWxkUHJlZGljYXRlIiwicmVkdWNlVHJlZUJ5U2VsZWN0b3IiLCJyZWR1Y2VUcmVlc0J5U2VsZWN0b3IiLCJwYXJzZXIiLCJDSElMRCIsIkFESkFDRU5UX1NJQkxJTkciLCJHRU5FUkFMX1NJQkxJTkciLCJERVNDRU5EQU5UIiwiU0VMRUNUT1IiLCJUWVBFX1NFTEVDVE9SIiwiQ0xBU1NfU0VMRUNUT1IiLCJJRF9TRUxFQ1RPUiIsIlVOSVZFUlNBTF9TRUxFQ1RPUiIsIkFUVFJJQlVURV9QUkVTRU5DRSIsIkFUVFJJQlVURV9WQUxVRSIsIlBTRVVET19DTEFTUyIsIlBTRVVET19FTEVNRU5UIiwiRVhBQ1RfQVRUUklCVVRFX09QRVJBVE9SIiwiV0hJVEVMSVNUX0FUVFJJQlVURV9PUEVSQVRPUiIsIkhZUEhFTkFURURfQVRUUklCVVRFX09QRVJBVE9SIiwiUFJFRklYX0FUVFJJQlVURV9PUEVSQVRPUiIsIlNVRkZJWF9BVFRSSUJVVEVfT1BFUkFUT1IiLCJTVUJTVFJJTkdfQVRUUklCVVRFX09QRVJBVE9SIiwidW5pcXVlIiwiYXJyIiwiU2V0IiwidW5pcXVlUmVkdWNlIiwiZm4iLCJub2RlcyIsInJlZHVjZSIsInNhZmVseUdlbmVyYXRlVG9rZW5zIiwic2VsZWN0b3IiLCJwYXJzZSIsImVyciIsIkVycm9yIiwibWF0Y2hBdHRyaWJ1dGVTZWxlY3RvciIsIm5vZGUiLCJ0b2tlbiIsIm9wZXJhdG9yIiwidmFsdWUiLCJuYW1lIiwibm9kZVByb3BzIiwiZGVzY3JpcHRvciIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsIm5vZGVQcm9wVmFsdWUiLCJ0eXBlIiwic3BsaXQiLCJpbmRleE9mIiwic3RhcnRzV2l0aCIsInNsaWNlIiwibGVuZ3RoIiwibWF0Y2hQc2V1ZG9TZWxlY3RvciIsInJvb3QiLCJwYXJhbWV0ZXJzIiwiZXZlcnkiLCJuIiwicmVuZGVyZWQiLCJmaXJzdENoaWxkIiwiZG9jdW1lbnQiLCJhZGFwdGVyIiwiYWN0aXZlRWxlbWVudCIsIm5vZGVUb0hvc3ROb2RlIiwiVHlwZUVycm9yIiwibm9kZU1hdGNoZXNUb2tlbiIsImJ1aWxkUHJlZGljYXRlRnJvbVRva2VuIiwiYm9keSIsImJvZHlUb2tlbiIsImlzQ29tcGxleFNlbGVjdG9yIiwidG9rZW5zIiwic29tZSIsImlzRWxlbWVudFR5cGUiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJtYXRjaGVzRWxlbWVudFR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwiaGFzVW5kZWZpbmVkVmFsdWVzIiwibWF0Y2hBZGphY2VudFNpYmxpbmdzIiwicHJlZGljYXRlIiwibWF0Y2hlcyIsInBhcmVudCIsInBhcmVudENoaWxkcmVuIiwibm9kZUluZGV4IiwiYWRqYWNlbnRTaWJsaW5nIiwicHVzaCIsIm1hdGNoR2VuZXJhbFNpYmxpbmciLCJ5b3VuZ2VyU2libGluZ3MiLCJjb25jYXQiLCJmaWx0ZXIiLCJtYXRjaERpcmVjdENoaWxkIiwibWF0Y2hEZXNjZW5kYW50IiwibWFwIiwiY2hpbGRyZW5PZk5vZGUiLCJlbGVtZW50cyIsIngiLCJ0YWciLCJyZXN1bHRzIiwiaW5kZXgiLCJyb290cyJdLCJzb3VyY2VzIjpbIi4uL3NyYy9zZWxlY3RvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUGFyc2VyIH0gZnJvbSAncnN0LXNlbGVjdG9yLXBhcnNlcic7XG5pbXBvcnQgdmFsdWVzIGZyb20gJ29iamVjdC52YWx1ZXMnO1xuaW1wb3J0IGZsYXQgZnJvbSAnYXJyYXkucHJvdG90eXBlLmZsYXQnO1xuaW1wb3J0IGlzIGZyb20gJ29iamVjdC1pcyc7XG5pbXBvcnQgaGFzIGZyb20gJ2hhcyc7XG5pbXBvcnQgZWxlbWVudHNCeUNvbnN0cnVjdG9yIGZyb20gJ2h0bWwtZWxlbWVudC1tYXAvYnlDb25zdHJ1Y3Rvcic7XG5pbXBvcnQge1xuICB0cmVlRmlsdGVyLFxuICBub2RlSGFzSWQsXG4gIGZpbmRQYXJlbnROb2RlLFxuICBub2RlTWF0Y2hlc09iamVjdFByb3BzLFxuICBjaGlsZHJlbk9mTm9kZSxcbiAgaGFzQ2xhc3NOYW1lLFxufSBmcm9tICcuL1JTVFRyYXZlcnNhbCc7XG5pbXBvcnQgeyBub2RlSGFzVHlwZSwgcHJvcHNPZk5vZGUgfSBmcm9tICcuL1V0aWxzJztcbmltcG9ydCBnZXRBZGFwdGVyIGZyb20gJy4vZ2V0QWRhcHRlcic7XG4vLyBvdXIgQ1NTIHNlbGVjdG9yIHBhcnNlciBpbnN0YW5jZVxuY29uc3QgcGFyc2VyID0gY3JlYXRlUGFyc2VyKCk7XG5cbi8vIENvbWJpbmF0b3JzIHRoYXQgYWxsb3cgeW91IHRvIGNoYW5jZSBzZWxlY3RvcnNcbmNvbnN0IENISUxEID0gJ2NoaWxkQ29tYmluYXRvcic7XG5jb25zdCBBREpBQ0VOVF9TSUJMSU5HID0gJ2FkamFjZW50U2libGluZ0NvbWJpbmF0b3InO1xuY29uc3QgR0VORVJBTF9TSUJMSU5HID0gJ2dlbmVyYWxTaWJsaW5nQ29tYmluYXRvcic7XG5jb25zdCBERVNDRU5EQU5UID0gJ2Rlc2NlbmRhbnRDb21iaW5hdG9yJztcblxuLy8gU2VsZWN0b3JzIGZvciB0YXJnZXRpbmcgZWxlbWVudHNcbmNvbnN0IFNFTEVDVE9SID0gJ3NlbGVjdG9yJztcbmNvbnN0IFRZUEVfU0VMRUNUT1IgPSAndHlwZVNlbGVjdG9yJztcbmNvbnN0IENMQVNTX1NFTEVDVE9SID0gJ2NsYXNzU2VsZWN0b3InO1xuY29uc3QgSURfU0VMRUNUT1IgPSAnaWRTZWxlY3Rvcic7XG5jb25zdCBVTklWRVJTQUxfU0VMRUNUT1IgPSAndW5pdmVyc2FsU2VsZWN0b3InO1xuY29uc3QgQVRUUklCVVRFX1BSRVNFTkNFID0gJ2F0dHJpYnV0ZVByZXNlbmNlU2VsZWN0b3InO1xuY29uc3QgQVRUUklCVVRFX1ZBTFVFID0gJ2F0dHJpYnV0ZVZhbHVlU2VsZWN0b3InO1xuLy8gQFRPRE8gd2UgZG9udCBzdXBwb3J0IHRoZXNlLCB0aHJvdyBpZiB0aGV5IGFyZSB1c2VkXG5jb25zdCBQU0VVRE9fQ0xBU1MgPSAncHNldWRvQ2xhc3NTZWxlY3Rvcic7XG5jb25zdCBQU0VVRE9fRUxFTUVOVCA9ICdwc2V1ZG9FbGVtZW50U2VsZWN0b3InO1xuXG5jb25zdCBFWEFDVF9BVFRSSUJVVEVfT1BFUkFUT1IgPSAnPSc7XG5jb25zdCBXSElURUxJU1RfQVRUUklCVVRFX09QRVJBVE9SID0gJ349JztcbmNvbnN0IEhZUEhFTkFURURfQVRUUklCVVRFX09QRVJBVE9SID0gJ3w9JztcbmNvbnN0IFBSRUZJWF9BVFRSSUJVVEVfT1BFUkFUT1IgPSAnXj0nO1xuY29uc3QgU1VGRklYX0FUVFJJQlVURV9PUEVSQVRPUiA9ICckPSc7XG5jb25zdCBTVUJTVFJJTkdfQVRUUklCVVRFX09QRVJBVE9SID0gJyo9JztcblxuZnVuY3Rpb24gdW5pcXVlKGFycikge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyKV07XG59XG5cbi8qKlxuICogQ2FsbHMgcmVkdWNlIG9uIGEgYXJyYXkgb2Ygbm9kZXMgd2l0aCB0aGUgcGFzc2VkXG4gKiBmdW5jdGlvbiwgcmV0dXJuaW5nIG9ubHkgdW5pcXVlIHJlc3VsdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqL1xuZnVuY3Rpb24gdW5pcXVlUmVkdWNlKGZuLCBub2Rlcykge1xuICByZXR1cm4gdW5pcXVlKG5vZGVzLnJlZHVjZShmbiwgW10pKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIENTUyBzZWxlY3RvciBhbmQgcmV0dXJucyBhIHNldCBvZiB0b2tlbnMgcGFyc2VkXG4gKiBieSBzY2FscGVsLlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKi9cbmZ1bmN0aW9uIHNhZmVseUdlbmVyYXRlVG9rZW5zKHNlbGVjdG9yKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZShzZWxlY3Rvcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNlbGVjdG9yOiAke3NlbGVjdG9yfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoQXR0cmlidXRlU2VsZWN0b3Iobm9kZSwgdG9rZW4pIHtcbiAgY29uc3QgeyBvcGVyYXRvciwgdmFsdWUsIG5hbWUgfSA9IHRva2VuO1xuICBjb25zdCBub2RlUHJvcHMgPSBwcm9wc09mTm9kZShub2RlKTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZVByb3BzLCBuYW1lKTtcbiAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5nZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgbm9kZVByb3BWYWx1ZSA9IG5vZGVQcm9wc1tuYW1lXTtcbiAgaWYgKHR5cGVvZiBub2RlUHJvcFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodG9rZW4udHlwZSA9PT0gQVRUUklCVVRFX1BSRVNFTkNFKSB7XG4gICAgcmV0dXJuIGhhcyhub2RlUHJvcHMsIHRva2VuLm5hbWUpO1xuICB9XG4gIC8vIE9ubHkgdGhlIGV4YWN0IHZhbHVlIG9wZXJhdG9yIChcIj1cIikgY2FuIG1hdGNoIG5vbi1zdHJpbmdzXG4gIGlmICh0eXBlb2Ygbm9kZVByb3BWYWx1ZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIGlmIChvcGVyYXRvciAhPT0gRVhBQ1RfQVRUUklCVVRFX09QRVJBVE9SKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXR0IGF0dHJpYnV0ZSB3aG9zZSB2YWx1ZSBpcyBleGFjdGx5IFwidmFsXCIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbYXR0cj1cInZhbFwiXSBtYXRjaGVzIGF0dHI9XCJ2YWxcIlxuICAgICAqL1xuICAgIGNhc2UgRVhBQ1RfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIGlzKG5vZGVQcm9wVmFsdWUsIHZhbHVlKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXR0IGF0dHJpYnV0ZSB3aG9zZSB2YWx1ZSBpcyBhIHdoaXRlc3BhY2Utc2VwYXJhdGVkXG4gICAgICogbGlzdCBvZiB3b3Jkcywgb25lIG9mIHdoaWNoIGlzIGV4YWN0bHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBbcmVsfj1cImNvcHlyaWdodFwiXSBtYXRjaGVzIHJlbD1cImNvcHlyaWdodCBvdGhlclwiXG4gICAgICovXG4gICAgY2FzZSBXSElURUxJU1RfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIG5vZGVQcm9wVmFsdWUuc3BsaXQoJyAnKS5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUsIGl0cyB2YWx1ZSBlaXRoZXIgYmVpbmcgZXhhY3RseSB0aGVcbiAgICAgKiB2YWx1ZSBvciBiZWdpbm5pbmcgd2l0aCB0aGUgdmFsdWUgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFtocmVmbGFuZ3w9XCJlblwiXSBtYXRjaGVzIGhyZWZsYW5nPVwiZW4tVVNcIlxuICAgICAqL1xuICAgIGNhc2UgSFlQSEVOQVRFRF9BVFRSSUJVVEVfT1BFUkFUT1I6XG4gICAgICByZXR1cm4gbm9kZVByb3BWYWx1ZSA9PT0gdmFsdWUgfHwgbm9kZVByb3BWYWx1ZS5zdGFydHNXaXRoKGAke3ZhbHVlfS1gKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXR0IGF0dHJpYnV0ZSB3aG9zZSB2YWx1ZSBiZWdpbnMgd2l0aCB0aGUgcHJlZml4IHZhbHVlLlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nIHRoZW4gdGhlIHNlbGVjdG9yIGRvZXMgbm90IHJlcHJlc2VudCBhbnl0aGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFt0eXBlXj1cImltYWdlXCJdIG1hdGNoZXMgdHlwZT1cImltYWdlb2JqZWN0XCJcbiAgICAgKi9cbiAgICBjYXNlIFBSRUZJWF9BVFRSSUJVVEVfT1BFUkFUT1I6XG4gICAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gZmFsc2UgOiBub2RlUHJvcFZhbHVlLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCkgPT09IHZhbHVlO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZWxlbWVudCB3aXRoIHRoZSBhdHQgYXR0cmlidXRlIHdob3NlIHZhbHVlIGVuZHMgd2l0aCB0aGUgc3VmZml4IHZhbHVlLlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nIHRoZW4gdGhlIHNlbGVjdG9yIGRvZXMgbm90IHJlcHJlc2VudCBhbnl0aGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFt0eXBlJD1cImltYWdlXCJdIG1hdGNoZXMgdHlwZT1cImltYWdlb2JqZWN0XCJcbiAgICAgKi9cbiAgICBjYXNlIFNVRkZJWF9BVFRSSUJVVEVfT1BFUkFUT1I6XG4gICAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gZmFsc2UgOiBub2RlUHJvcFZhbHVlLnNsaWNlKC12YWx1ZS5sZW5ndGgpID09PSB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXR0IGF0dHJpYnV0ZSB3aG9zZSB2YWx1ZSBjb250YWlucyBhdCBsZWFzdCBvbmVcbiAgICAgKiBpbnN0YW5jZSBvZiB0aGUgdmFsdWUuIElmIHZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcgdGhlbiB0aGVcbiAgICAgKiBzZWxlY3RvciBkb2VzIG5vdCByZXByZXNlbnQgYW55dGhpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbdGl0bGUqPVwiaGVsbG9cIl0gbWF0Y2hlcyB0aXRsZT1cIndlbGwgaGVsbG8gdGhlcmVcIlxuICAgICAqL1xuICAgIGNhc2UgU1VCU1RSSU5HX0FUVFJJQlVURV9PUEVSQVRPUjpcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBmYWxzZSA6IG5vZGVQcm9wVmFsdWUuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuenltZTo6U2VsZWN0b3I6IFVua25vd24gYXR0cmlidXRlIHNlbGVjdG9yIG9wZXJhdG9yIFwiJHtvcGVyYXRvcn1cImApO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbWF0Y2hQc2V1ZG9TZWxlY3Rvcihub2RlLCB0b2tlbiwgcm9vdCkge1xuICBjb25zdCB7IG5hbWUsIHBhcmFtZXRlcnMgfSA9IHRva2VuO1xuICBpZiAobmFtZSA9PT0gJ25vdCcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICByZXR1cm4gcGFyYW1ldGVycy5ldmVyeSgoc2VsZWN0b3IpID0+IHJlZHVjZVRyZWVCeVNlbGVjdG9yKHNlbGVjdG9yLCBub2RlKS5sZW5ndGggPT09IDApO1xuICB9XG4gIGlmIChuYW1lID09PSAnZW1wdHknKSB7XG4gICAgcmV0dXJuIHRyZWVGaWx0ZXIobm9kZSwgKG4pID0+IG4gIT09IG5vZGUpLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBpZiAobmFtZSA9PT0gJ2ZpcnN0LWNoaWxkJykge1xuICAgIGNvbnN0IHsgcmVuZGVyZWQgfSA9IGZpbmRQYXJlbnROb2RlKHJvb3QsIG5vZGUpO1xuICAgIGNvbnN0IFtmaXJzdENoaWxkXSA9IHJlbmRlcmVkO1xuICAgIHJldHVybiBmaXJzdENoaWxkID09PSBub2RlO1xuICB9XG4gIGlmIChuYW1lID09PSAnbGFzdC1jaGlsZCcpIHtcbiAgICBjb25zdCB7IHJlbmRlcmVkIH0gPSBmaW5kUGFyZW50Tm9kZShyb290LCBub2RlKTtcbiAgICByZXR1cm4gcmVuZGVyZWRbcmVuZGVyZWQubGVuZ3RoIC0gMV0gPT09IG5vZGU7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdmb2N1cycpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnp5bWU6OlNlbGVjdG9yIGRvZXMgbm90IHN1cHBvcnQgdGhlIFwiOmZvY3VzXCIgcHNldWRvLWVsZW1lbnQgd2l0aG91dCBhIGdsb2JhbCBgZG9jdW1lbnRgLicpO1xuICAgIH1cbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcigpO1xuICAgIC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGFkYXB0ZXIubm9kZVRvSG9zdE5vZGUobm9kZSkgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFbnp5bWU6OlNlbGVjdG9yIGRvZXMgbm90IHN1cHBvcnQgdGhlIFwiJHt0b2tlbi5uYW1lfVwiIHBzZXVkby1lbGVtZW50IG9yIHBzZXVkby1jbGFzcyBzZWxlY3RvcnMuYCk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCBhIHRva2VuIGFuZCBkZXRlcm1pbmVzIGlmIHRoZSBub2RlXG4gKiBtYXRjaGVzIHRoZSBwcmVkaWNhdGUgZGVmaW5lZCBieSB0aGUgdG9rZW4uXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gKi9cbmZ1bmN0aW9uIG5vZGVNYXRjaGVzVG9rZW4obm9kZSwgdG9rZW4sIHJvb3QpIHtcbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgdHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgIC8qKlxuICAgICAqIE1hdGNoIGV2ZXJ5IG5vZGVcbiAgICAgKiBAZXhhbXBsZSAnKicgbWF0Y2hlcyBldmVyeSBub2RlXG4gICAgICovXG4gICAgY2FzZSBVTklWRVJTQUxfU0VMRUNUT1I6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBhZ2FpbnN0IHRoZSBjbGFzc05hbWUgcHJvcFxuICAgICAqIEBleGFtcGxlICcuYWN0aXZlJyBtYXRjaGVzIDxkaXYgY2xhc3NOYW1lPSdhY3RpdmUnIC8+XG4gICAgICovXG4gICAgY2FzZSBDTEFTU19TRUxFQ1RPUjpcbiAgICAgIHJldHVybiBoYXNDbGFzc05hbWUobm9kZSwgdG9rZW4ubmFtZSk7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIHR5cGUgbWF0Y2hpbmdcbiAgICAgKiBAZXhhbXBsZSAnZGl2JyBtYXRjaGVzIDxkaXYgLz5cbiAgICAgKi9cbiAgICBjYXNlIFRZUEVfU0VMRUNUT1I6XG4gICAgICByZXR1cm4gbm9kZUhhc1R5cGUobm9kZSwgdG9rZW4ubmFtZSk7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYWdhaW5zdCB0aGUgYGlkYCBwcm9wXG4gICAgICogQGV4YW1wbGUgJyNuYXYnIG1hdGNoZXMgPHVsIGlkPVwibmF2XCIgLz5cbiAgICAgKi9cbiAgICBjYXNlIElEX1NFTEVDVE9SOlxuICAgICAgcmV0dXJuIG5vZGVIYXNJZChub2RlLCB0b2tlbi5uYW1lKTtcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIGlmIGFuIGF0dHJpYnV0ZSBpcyBwcmVzZW50LCByZWdhcmRsZXNzXG4gICAgICogb2YgaXRzIHZhbHVlXG4gICAgICogQGV4YW1wbGUgJ1tkaXNhYmxlZF0nIG1hdGNoZXMgPGEgZGlzYWJsZWQgLz5cbiAgICAgKi9cbiAgICBjYXNlIEFUVFJJQlVURV9QUkVTRU5DRTpcbiAgICAgIHJldHVybiBtYXRjaEF0dHJpYnV0ZVNlbGVjdG9yKG5vZGUsIHRva2VuKTtcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIGlmIGFuIGF0dHJpYnV0ZSBpcyBwcmVzZW50IHdpdGggdGhlXG4gICAgICogcHJvdmlkZWQgdmFsdWVcbiAgICAgKiBAZXhhbXBsZSAnW2RhdGEtZm9vPWZvb10nIG1hdGNoZXMgPGRpdiBkYXRhLWZvbz1cImZvb1wiIC8+XG4gICAgICovXG4gICAgY2FzZSBBVFRSSUJVVEVfVkFMVUU6XG4gICAgICByZXR1cm4gbWF0Y2hBdHRyaWJ1dGVTZWxlY3Rvcihub2RlLCB0b2tlbik7XG4gICAgY2FzZSBQU0VVRE9fRUxFTUVOVDpcbiAgICBjYXNlIFBTRVVET19DTEFTUzpcbiAgICAgIHJldHVybiBtYXRjaFBzZXVkb1NlbGVjdG9yKG5vZGUsIHRva2VuLCByb290KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRva2VuIHR5cGU6ICR7dG9rZW4udHlwZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYVxuICogbm9kZSBtYXRjaGVzIGV2ZXJ5IHRva2VuIGluIHRoZSBib2R5IG9mIGEgc2VsZWN0b3JcbiAqIHRva2VuLlxuICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAqL1xuZnVuY3Rpb24gYnVpbGRQcmVkaWNhdGVGcm9tVG9rZW4odG9rZW4sIHJvb3QpIHtcbiAgcmV0dXJuIChub2RlKSA9PiB0b2tlbi5ib2R5LmV2ZXJ5KChib2R5VG9rZW4pID0+IG5vZGVNYXRjaGVzVG9rZW4obm9kZSwgYm9keVRva2VuLCByb290KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgcGFyc2VkIHNlbGVjdG9yIGlzIGEgY29tcGxleCBzZWxlY3Rvciwgd2hpY2hcbiAqIGlzIGRlZmluZWQgYXMgYSBzZWxlY3RvciB0aGF0IGNvbnRhaW5zIGNvbWJpbmF0b3JzLlxuICogQHBhcmFtIHtBcnJheTxUb2tlbj59IHRva2Vuc1xuICovXG5mdW5jdGlvbiBpc0NvbXBsZXhTZWxlY3Rvcih0b2tlbnMpIHtcbiAgcmV0dXJuIHRva2Vucy5zb21lKCh0b2tlbikgPT4gdG9rZW4udHlwZSAhPT0gU0VMRUNUT1IpO1xufVxuXG5cbi8qKlxuICogVGFrZXMgYSBjb21wb25lbnQgY29uc3RydWN0b3IsIG9iamVjdCwgb3Igc3RyaW5nIHJlcHJlc2VudGluZ1xuICogYSBzaW1wbGUgc2VsZWN0b3IgYW5kIHJldHVybnMgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBjYW5cbiAqIGJlIGFwcGxpZWQgdG8gYSBzaW5nbGUgbm9kZS5cbiAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFByZWRpY2F0ZShzZWxlY3Rvcikge1xuICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgYSBzdHJpbmcsIHBhcnNlIGl0IGFzIGEgc2ltcGxlIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHRva2VucyA9IHNhZmVseUdlbmVyYXRlVG9rZW5zKHNlbGVjdG9yKTtcbiAgICBpZiAoaXNDb21wbGV4U2VsZWN0b3IodG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4IENTUyBzZWxlY3RvcnMnKTtcbiAgICB9XG4gICAgLy8gU2ltcGxlIHNlbGVjdG9ycyBvbmx5IGhhdmUgYSBzaW5nbGUgc2VsZWN0b3IgdG9rZW5cbiAgICByZXR1cm4gYnVpbGRQcmVkaWNhdGVGcm9tVG9rZW4odG9rZW5zWzBdKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBzZWxlY3RvciBpcyBhbiBlbGVtZW50IHR5cGUsIGNoZWNrIGlmIHRoZSBub2RlJ3MgdHlwZSBtYXRjaGVzXG4gIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKCk7XG4gIGNvbnN0IGlzRWxlbWVudFR5cGUgPSBhZGFwdGVyLmlzVmFsaWRFbGVtZW50VHlwZVxuICAgID8gYWRhcHRlci5pc1ZhbGlkRWxlbWVudFR5cGUoc2VsZWN0b3IpXG4gICAgOiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbic7XG4gIGlmIChpc0VsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIChub2RlKSA9PiBhZGFwdGVyLm1hdGNoZXNFbGVtZW50VHlwZShub2RlLCBzZWxlY3Rvcik7XG4gIH1cbiAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIGFuIG5vbi1lbXB0eSBvYmplY3QsIHRyZWF0IHRoZSBrZXlzL3ZhbHVlcyBhcyBwcm9wc1xuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnb2JqZWN0Jykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzZWxlY3RvcikgJiYgc2VsZWN0b3IgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoc2VsZWN0b3IpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGhhc1VuZGVmaW5lZFZhbHVlcyA9IHZhbHVlcyhzZWxlY3Rvcikuc29tZSgodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgaWYgKGhhc1VuZGVmaW5lZFZhbHVlcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbnp5bWU6OlByb3BzIGNhbuKAmXQgaGF2ZSBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRyeSB1c2luZyDigJhmaW5kV2hlcmUoKeKAmSBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChub2RlKSA9PiBub2RlTWF0Y2hlc09iamVjdFByb3BzKG5vZGUsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW56eW1lOjpTZWxlY3RvciBkb2VzIG5vdCBzdXBwb3J0IGFuIGFycmF5LCBudWxsLCBvciBlbXB0eSBvYmplY3QgYXMgYSBzZWxlY3RvcicpO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW56eW1lOjpTZWxlY3RvciBleHBlY3RzIGEgc3RyaW5nLCBvYmplY3QsIG9yIHZhbGlkIGVsZW1lbnQgdHlwZSAoQ29tcG9uZW50IENvbnN0cnVjdG9yKScpO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgb25seSBub2RlcyB3aGljaCBhcmUgYWRqYWNlbnQgc2libGluZ3MgKGRpcmVjdCBuZXh0IHNpYmxpbmcpXG4gKiBhZ2FpbnN0IGEgcHJlZGljYXRlLCByZXR1cm5pbmcgdGhvc2UgdGhhdCBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7Tm9kZX0gcm9vdFxuICovXG5mdW5jdGlvbiBtYXRjaEFkamFjZW50U2libGluZ3Mobm9kZXMsIHByZWRpY2F0ZSwgcm9vdCkge1xuICByZXR1cm4gbm9kZXMucmVkdWNlKChtYXRjaGVzLCBub2RlKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gZmluZFBhcmVudE5vZGUocm9vdCwgbm9kZSk7XG4gICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHRoZXJlJ3Mgbm8gc2libGluZ3NcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudENoaWxkcmVuID0gY2hpbGRyZW5PZk5vZGUocGFyZW50KTtcbiAgICBjb25zdCBub2RlSW5kZXggPSBwYXJlbnRDaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgIGNvbnN0IGFkamFjZW50U2libGluZyA9IHBhcmVudENoaWxkcmVuW25vZGVJbmRleCArIDFdO1xuICAgIC8vIE5vIHNpYmxpbmdcbiAgICBpZiAoIWFkamFjZW50U2libGluZykge1xuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuICAgIGlmIChwcmVkaWNhdGUoYWRqYWNlbnRTaWJsaW5nKSkge1xuICAgICAgbWF0Y2hlcy5wdXNoKGFkamFjZW50U2libGluZyk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9LCBbXSk7XG59XG5cbi8qKlxuICogTWF0Y2hlcyBvbmx5IG5vZGVzIHdoaWNoIGFyZSBnZW5lcmFsIHNpYmxpbmdzIChhbnkgc2libGluZyAqYWZ0ZXIqKVxuICogYWdhaW5zdCBhIHByZWRpY2F0ZSwgcmV0dXJuaW5nIHRob3NlIHRoYXQgbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2Rlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gKiBAcGFyYW0ge05vZGV9IHJvb3RcbiAqL1xuZnVuY3Rpb24gbWF0Y2hHZW5lcmFsU2libGluZyhub2RlcywgcHJlZGljYXRlLCByb290KSB7XG4gIHJldHVybiB1bmlxdWVSZWR1Y2UoKG1hdGNoZXMsIG5vZGUpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBmaW5kUGFyZW50Tm9kZShyb290LCBub2RlKTtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudENoaWxkcmVuID0gY2hpbGRyZW5PZk5vZGUocGFyZW50KTtcbiAgICBjb25zdCBub2RlSW5kZXggPSBwYXJlbnRDaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgIGNvbnN0IHlvdW5nZXJTaWJsaW5ncyA9IHBhcmVudENoaWxkcmVuLnNsaWNlKG5vZGVJbmRleCArIDEpO1xuICAgIHJldHVybiBtYXRjaGVzLmNvbmNhdCh5b3VuZ2VyU2libGluZ3MuZmlsdGVyKHByZWRpY2F0ZSkpO1xuICB9LCBub2Rlcyk7XG59XG5cbi8qKlxuICogTWF0Y2hlcyBvbmx5IG5vZGVzIHdoaWNoIGFyZSBkaXJlY3QgY2hpbGRyZW4gKG5vdCBncmFuZGNoaWxkcmVuLCBldGMuKVxuICogYWdhaW5zdCBhIHByZWRpY2F0ZSwgcmV0dXJuaW5nIHRob3NlIHRoYXQgbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2Rlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gKi9cbmZ1bmN0aW9uIG1hdGNoRGlyZWN0Q2hpbGQobm9kZXMsIHByZWRpY2F0ZSkge1xuICByZXR1cm4gdW5pcXVlUmVkdWNlKFxuICAgIChtYXRjaGVzLCBub2RlKSA9PiBtYXRjaGVzLmNvbmNhdChjaGlsZHJlbk9mTm9kZShub2RlKS5maWx0ZXIocHJlZGljYXRlKSksXG4gICAgbm9kZXMsXG4gICk7XG59XG5cbi8qKlxuICogTWF0Y2hlcyBhbGwgZGVzY2VuZGFudCBub2RlcyBhZ2FpbnN0IGEgcHJlZGljYXRlLFxuICogcmV0dXJuaW5nIHRob3NlIHRoYXQgbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2Rlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gKi9cbmZ1bmN0aW9uIG1hdGNoRGVzY2VuZGFudChub2RlcywgcHJlZGljYXRlKSB7XG4gIHJldHVybiB1bmlxdWVSZWR1Y2UoXG4gICAgKG1hdGNoZXMsIG5vZGUpID0+IG1hdGNoZXMuY29uY2F0KHRyZWVGaWx0ZXIobm9kZSwgcHJlZGljYXRlKSksXG4gICAgZmxhdChub2Rlcy5tYXAoY2hpbGRyZW5PZk5vZGUpKSxcbiAgKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBSU1QgYW5kIHJlZHVjZXMgaXQgdG8gYSBzZXQgb2Ygbm9kZXMgbWF0Y2hpbmdcbiAqIHRoZSBzZWxlY3Rvci4gVGhlIHNlbGVjdG9yIGNhbiBiZSBhIHNpbXBsZSBzZWxlY3Rvciwgd2hpY2hcbiAqIGlzIGhhbmRsZWQgYnkgYGJ1aWxkUHJlZGljYXRlYCwgb3IgYSBjb21wbGV4IENTUyBzZWxlY3RvciB3aGljaFxuICogcmVkdWNlVHJlZUJ5U2VsZWN0b3IgcGFyc2VzIGFuZCByZWR1Y2VzIHRoZSB0cmVlIGJhc2VkIG9uIHRoZSBjb21iaW5hdG9ycy5cbiAqXG4gKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvclxuICogQHBhcmFtIHtSU1ROb2RlfSByb290XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VUcmVlQnlTZWxlY3RvcihzZWxlY3Rvciwgcm9vdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudHNCeUNvbnN0cnVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZsYXQoZWxlbWVudHMubWFwKCh4KSA9PiByZWR1Y2VUcmVlQnlTZWxlY3Rvcih4LnRhZywgcm9vdCkpKTtcblxuICAgICAgLy8gd2hlbiBodHRwczovL2dpdGh1Yi5jb20vYXdlYXJ5L3JzdC1zZWxlY3Rvci1wYXJzZXIvaXNzdWVzLzE1IGlzIHJlc29sdmVkXG4gICAgICAvLyBjb25zdCBodG1sVGFnTmFtZXMgPSBlbGVtZW50cy5tYXAoeCA9PiB4LnRhZykuam9pbignLCAnKTtcbiAgICAgIC8vIHJldHVybiByZWR1Y2VUcmVlQnlTZWxlY3RvcihodG1sVGFnTmFtZXMsIHJvb3QpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHNlbGVjdG9yID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0cmVlRmlsdGVyKHJvb3QsIGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKSk7XG4gIH1cblxuICBsZXQgcmVzdWx0cyA9IFtdO1xuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHRva2VucyA9IHNhZmVseUdlbmVyYXRlVG9rZW5zKHNlbGVjdG9yKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2luZGV4XTtcbiAgICAgIC8qKlxuICAgICAgICogVGhlcmUgYXJlIHR3byB0eXBlcyBvZiB0b2tlbnMgaW4gYSBDU1Mgc2VsZWN0b3I6XG4gICAgICAgKlxuICAgICAgICogMS4gU2VsZWN0b3IgdG9rZW5zLiBUaGVzZSB0YXJnZXQgbm9kZXMgZGlyZWN0bHksIGxpa2VcbiAgICAgICAqICAgIHR5cGUgb3IgYXR0cmlidXRlIHNlbGVjdG9ycy4gVGhlc2UgYXJlIGVhc3kgdG8gYXBwbHlcbiAgICAgICAqICAgIGJlY2F1c2Ugd2UgY2FuIHRyYXZlcnNlIHRoZSB0cmVlIGFuZCByZXR1cm4gb25seVxuICAgICAgICogICAgdGhlIG5vZGVzIHRoYXQgbWF0Y2ggdGhlIHByZWRpY2F0ZS5cbiAgICAgICAqXG4gICAgICAgKiAyLiBDb21iaW5hdG9yIHRva2Vucy4gVGhlc2UgdG9rZW5zIGNoYWluIHRvZ2V0aGVyXG4gICAgICAgKiAgICBzZWxlY3RvciBub2Rlcy4gRm9yIGV4YW1wbGUgPiBmb3IgY2hpbGRyZW4sIG9yICtcbiAgICAgICAqICAgIGZvciBhZGphY2VudCBzaWJsaW5ncy4gVGhlc2UgYXJlIGhhcmRlciB0byBtYXRjaFxuICAgICAgICogICAgYXMgd2UgaGF2ZSB0byB0cmFjayB3aGVyZSBpbiB0aGUgdHJlZSB3ZSBhcmVcbiAgICAgICAqICAgIHRvIGRldGVybWluZSBpZiBhIHNlbGVjdG9yIG5vZGUgYXBwbGllcyBvciBub3QuXG4gICAgICAgKi9cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBTRUxFQ1RPUikge1xuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBidWlsZFByZWRpY2F0ZUZyb21Ub2tlbih0b2tlbiwgcm9vdCk7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdCh0cmVlRmlsdGVyKHJvb3QsIHByZWRpY2F0ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgY2FuIGFzc3VtZSB0aGVyZSBhbHdheXMgYWxsIHByZXZpb3VzbHkgbWF0Y2hlZCB0b2tlbnMgc2luY2Ugc2VsZWN0b3JzXG4gICAgICAgIC8vIGNhbm5vdCBzdGFydCB3aXRoIGNvbWJpbmF0b3JzLlxuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHRva2VuO1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhlIG5leHQgdG9rZW4gaXMgYSBzZWxlY3Rvciwgc28gbW92ZSB0aGUgaW5kZXhcbiAgICAgICAgLy8gZm9yd2FyZCBhbmQgYnVpbGQgdGhlIHByZWRpY2F0ZS5cbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0gYnVpbGRQcmVkaWNhdGVGcm9tVG9rZW4odG9rZW5zW2luZGV4XSwgcm9vdCk7XG4gICAgICAgIC8vIFdlIG1hdGNoIGFnYWluc3Qgb25seSB0aGUgbm9kZXMgd2hpY2ggaGF2ZSBhbHJlYWR5IGJlZW4gbWF0Y2hlZCxcbiAgICAgICAgLy8gc2luY2UgYSBjb21iaW5hdG9yIGlzIG1lYW50IHRvIHJlZmluZSBhIHByZXZpb3VzIHNlbGVjdG9yLlxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAvLyBUaGUgKyBjb21iaW5hdG9yXG4gICAgICAgICAgY2FzZSBBREpBQ0VOVF9TSUJMSU5HOlxuICAgICAgICAgICAgcmVzdWx0cyA9IG1hdGNoQWRqYWNlbnRTaWJsaW5ncyhyZXN1bHRzLCBwcmVkaWNhdGUsIHJvb3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gVGhlIH4gY29tYmluYXRvclxuICAgICAgICAgIGNhc2UgR0VORVJBTF9TSUJMSU5HOlxuICAgICAgICAgICAgcmVzdWx0cyA9IG1hdGNoR2VuZXJhbFNpYmxpbmcocmVzdWx0cywgcHJlZGljYXRlLCByb290KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFRoZSA+IGNvbWJpbmF0b3JcbiAgICAgICAgICBjYXNlIENISUxEOlxuICAgICAgICAgICAgcmVzdWx0cyA9IG1hdGNoRGlyZWN0Q2hpbGQocmVzdWx0cywgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFRoZSAnICcgKHdoaXRlc3BhY2UpIGNvbWJpbmF0b3JcbiAgICAgICAgICBjYXNlIERFU0NFTkRBTlQ6IHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBtYXRjaERlc2NlbmRhbnQocmVzdWx0cywgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbWJpbmF0b3Igc2VsZWN0b3I6ICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5kZXggKz0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW56eW1lOjpTZWxlY3RvciBleHBlY3RzIGEgc3RyaW5nLCBvYmplY3QsIG9yIENvbXBvbmVudCBDb25zdHJ1Y3RvcicpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlVHJlZXNCeVNlbGVjdG9yKHNlbGVjdG9yLCByb290cykge1xuICBjb25zdCByZXN1bHRzID0gcm9vdHMubWFwKChuKSA9PiByZWR1Y2VUcmVlQnlTZWxlY3RvcihzZWxlY3RvciwgbikpO1xuICByZXR1cm4gdW5pcXVlKGZsYXQocmVzdWx0cywgMSkpO1xufVxuIl19